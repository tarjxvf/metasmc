/* This file includes codes generating genealogies over reference genome.
 * Genealogy are simulated under Sequentially Markov Coalescent model proposed by McVean and Cardin (2005) */

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

#include "util.h"
#include "smc.h"
#include "mutation.h"
#include "bit.h"

double ulast;	// Last uniform random variable generated by abs_time
size_t nodesize[] = {sizeof(struct coal_node), sizeof(struct migr_node), sizeof(struct xover_node), sizeof(struct sam_node) + sizeof(struct list_head), sizeof(struct dummy_node), sizeof(struct dummy_node)};

struct tsindex *tsindex_alloc(int maxedges)
{
	struct tsindex *tr;

	tr = malloc(sizeof(struct tsindex));
	tr->index = bit_alloc(maxedges);
	tr->maxedges = maxedges;
	tr->maxnodes = tr->nedges = 0;
	tr->edges = malloc(sizeof(struct edge *) * maxedges);
	memset(tr->edges, 0, sizeof(struct edge *) * maxedges);
	list_init(&tr->free_list);

	return tr;
}

void tsindex_reset(struct tsindex *tr)
{
	struct list_head *l;
	struct list *queue;

	memset(tr->edges, 0, sizeof(struct edge *) * tr->maxedges);
	tr->nedges = tr->maxnodes = 0;
	bit_clear(tr->index);
	memset(tr->index->freq, 0, sizeof(double) * tr->index->n);

	/* Clear free list. */
	queue = &tr->free_list;
	l = queue->front;
	while(l){
		struct list_head *tmp;

		tmp = l->next;
		__list_remove(queue, l);
		free(l);
		l = tmp;
	}
}

struct edge *tsindex_search(struct tsindex *tr, double g, double *cum)
{
	int eid;

	eid = bit_getindex(tr->index, g);
	*cum = bit_cumfreq(tr->index, eid - 1);

	return tr->edges[eid];
}

double tsindex_size(struct tsindex *tr)
{
	return bit_total(tr->index);
}

void tsindex_add(struct tsindex *tr, struct edge *e)
{
	struct list *queue;
	double diff;
	int id;

	diff = e->top->t - e->bot->t;
	queue = &tr->free_list;

	if(queue->front == NULL){
		/* Allocate a new node in binary indexed tree. */
		id = bit_append(tr->index, diff);
		tr->maxnodes++;
		if(tr->maxnodes >= tr->maxedges){
			tr->edges = realloc(tr->edges, sizeof(struct edge *) * (tr->maxedges + 1000));
			memset(tr->edges + tr->maxedges, 0, sizeof(struct edge *) * 1000);
			tr->maxedges += 1000;
		}

	}else{
		struct list_head *l;
		int *ptr;

		/* Get a existing empty node in binary indexed tree. */
		l = queue->front;
		ptr = (int *)GET_OBJ(l);
		id = *ptr;
		__list_remove(queue, l);
		free(l);

		bit_update(tr->index, id, diff);
	}

	e->xtid = id;
	tr->edges[id] = e;
	tr->nedges++;
}

void tsindex_update(struct tsindex *tr, struct edge *e, double diff)
{
	bit_update(tr->index, e->xtid, diff);
}

/* Clear a node in binary indexed tree. */
void tsindex_clear(struct tsindex *tr, struct edge *e)
{
	struct list_head *l;
	int *pidx, id;
	double diff;

	id = e->xtid;
	diff = bit_getvalue(tr->index, id);
	bit_update(tr->index, id, -diff);
	tr->edges[id] = NULL;
	e->xtid = 0;

	/* Add freed id to the queue. */
	l = malloc(sizeof(struct list_head) + sizeof(int));
	pidx = (int *)GET_OBJ(l);
	*pidx = id;
	__list_append(&tr->free_list, l);
	tr->nedges--;
}

void tsindex_free(struct tsindex *tr)
{
	free(tr->edges);
	bit_free(tr->index);
	free(tr);
}

void tsindex_dump(struct tsindex *tr)
{
	struct list_head *l;
	struct edge *e;
	int i;

	fprintf(stderr, "tr->nedges=%d, tr->maxnodes=%d, tr->maxedges=%d, G->tr_xoveredges=", tr->nedges, tr->maxnodes, tr->maxedges);
	for(i = 1; i <= tr->maxnodes; i++){
		e = tr->edges[i];
		if(e)
			fprintf(stderr, "%x(%.10f, %.10f, xtid=%d), ", e, e->bot->t, e->top->t, e->xtid);
		else
			fprintf(stderr, "NULL, ");
	}
	fprintf(stderr, "\n");

	fprintf(stderr, "free_list=");
	l = tr->free_list.front;
	while(l){
		int *pidx;
		pidx = (int *)GET_OBJ(l);
		fprintf(stderr, "%d->", *pidx);
		l = l->next;
	}
	fprintf(stderr, "\n");

	bit_print(tr->index);
}

void free_node(struct genealogy *G, struct node *nd)
{
	struct config *cfg;

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s, nd=%x\n", __func__, nd);
#endif

	if(nd->type == NODE_SAM){
		struct list_head *l;

		l = GET_LIST(nd);
		free(l);

	}else{
		free(nd);
	}
#ifdef DEBUG
	fprintf(stderr, "Freed node %x\n\n", nd);
#endif
}

struct node *alloc_node(struct genealogy *G, int type, int pop, double t)
{
	struct config *cfg;
	struct node *nd;
	char *ptr;

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	ptr = malloc(nodesize[type]);
	memset(ptr, 0, nodesize[type]);

	if(type == NODE_SAM){
		struct list_head *l;

		l = (struct list_head *)ptr;
		nd = (struct node *)GET_OBJ(l);

	}else{
		nd = (struct node *)ptr;
	}

	nd->type = type;
	nd->pop = pop;
	nd->t = t;
#ifdef DEBUG
	fprintf(stderr, "Allocated node %x at time %.6f with type %d in subpopulation %d\n\n", nd, nd->t, nd->type, nd->pop);
#endif
	return nd;
}

void free_edge(struct genealogy *G, struct edge *e)
{
	struct config *cfg;
	struct list_head *l;

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s, e=%x\n", __func__, e);
#endif
	l = GET_LIST(e);
	free(l);
#ifdef DEBUG
	fprintf(stderr, "Freed edge %x\n", e);
#endif
}

int edgeid = 0;
struct edge *alloc_edge(struct genealogy *G, struct node *top, struct node *bot)
{
	struct config *cfg;
	struct list_head *l;
	struct edge *e;

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	l = malloc(sizeof(struct edge) + sizeof(struct list_head));
	memset(l, 0, sizeof(struct edge) + sizeof(struct list_head));

	e = (struct edge *)GET_OBJ(l);
	e->top = top;
	e->bot = bot;
	e->xtid = e->idx = 0;

#ifdef DEBUG
	fprintf(stderr, "Allocated edge %x, top node=%x(t=%.6f, type=%d), bot node=%x(t=%.6f, type=%d)\n", e, e->top, e->top->t, e->top->type, e->bot, e->bot->t, e->bot->type);
#endif
	return e;
}

void __add_edge(struct genealogy *G, int pop, struct edge *e)
{
	struct population *ppop;
	struct list *eid_queue;
	struct list_head *l;
	int idx, *ptr;

	ppop = &G->pops[pop];
	eid_queue = &ppop->idx_queue;
	if(eid_queue->front == NULL){
		idx = ppop->nedges++;
		if(idx >= ppop->maxedges){
			ppop->maxedges += 100;
			ppop->eptrs = realloc(ppop->eptrs, ppop->maxedges * sizeof(struct edge *));
		}
		ppop->eptrs[idx] = NULL;

	}else{
		l = eid_queue->front;
		ptr = (int *)GET_OBJ(l);
		idx = *ptr;
		__list_remove(eid_queue, l);
		free(l);
	}

//	if(ppop->eptrs[idx])
//		free_edge(G, ppop->eptrs[idx]);
	ppop->eptrs[idx] = e;
	e->idx = idx;
}

/* Add an edge to a population. */
void add_edge(struct genealogy *G, int pop, struct edge *e)
{
	tsindex_add(G->tr_xover, e);
	list_append(&G->e_list, e);
	__add_edge(G, pop, e);
}

void __remove_edge(struct genealogy *G, int pop, struct edge *e)
{
	struct population *ppop;
	void *l;
	int *pidx, idx;

	ppop = &G->pops[pop];
	idx = e->idx;

	/* Insert index of the edge into the queue. */
	l = malloc(sizeof(struct list_head) + sizeof(int));
	pidx = l + sizeof(struct list_head);
	*pidx = idx;
	__list_append(&ppop->idx_queue, l);
	ppop->eptrs[idx] = NULL;
}

void remove_edge(struct genealogy *G, int pop, struct edge *e)
{
	__remove_edge(G, pop, e);
	tsindex_clear(G->tr_xover, e);
	list_remove(&G->e_list, e);
	free_edge(G, e);
}

void dump_events(struct genealogy *G)
{
	struct list_head *l;

	l = G->evlist->front;
	fprintf(stderr, "Event list: G->evlist");
	while(l){
		struct event *ev;
		ev = (struct event *)GET_OBJ(l);
		fprintf(stderr, "->");
		print_event(ev);
		l = l->next;
	}
	fprintf(stderr, "\n");
}

void dump_edges(struct genealogy *G)
{
	struct config *cfg;
	struct list_head *l;
	struct sam_node *sn;
	struct node *n;
	struct edge *e;
	int i, j;

	fprintf(stderr, "Entering %s\n", __func__);

	cfg = G->cfg;
	l = G->e_list.front;
	fprintf(stderr, "Global edge list");
	while(l){
		e = (struct edge *)GET_OBJ(l);
		fprintf(stderr, "->%x(%.10f, %.10f, xtid=%d)", e, e->bot->t, e->top->t, e->xtid);
		l = l->next;
	}
	fprintf(stderr, "\n");
	fprintf(stderr, "G->e_list.n=%d\n\n", G->e_list.n);
	tsindex_dump(G->tr_xover);
	fprintf(stderr, "Dangling edges:");
	n = G->localMRCA;
	while(n && n->in){
		e = n->in;
		fprintf(stderr, "%x:(%.6f, %.6f), ", e, e->bot->t, e->top->t);
		n = e->top;
	}
	fprintf(stderr, "\n");

	for(i = 0; i < cfg->npop_all; i++){
		fprintf(stderr, "Population %d:", i);

		fprintf(stderr, "All edges:[");
		for(j = 0; j < G->pops[i].nedges; j++){
			e = G->pops[i].eptrs[j];
			if(e)
//				fprintf(stderr, "%x(%.10f, %.10f, %d, %d),", e, e->bot->t, e->top->t, e->bdeleted, e->inqueue);
				fprintf(stderr, "%x(top=%.10f, top=%.10f, xtid=%d),", e, e->bot->t, e->top->t, e->xtid);

			else
				fprintf(stderr, "(NULL),");
		}
		fprintf(stderr, "]\n");
	}

	fprintf(stderr, "Leaving %s\n", __func__);
}

void remove_coal_node(struct genealogy *G, struct coal_node *nd, int iout, int tsupdate)
{
	struct node *n2;
	struct edge *e;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s, nd=%x, iout=%d\n", __func__, nd, iout);
#endif
	e = nd->out[1 - iout];
	n2 = e->bot;

	/* Extend edges above the coalescent node to be removed. */
	if(tsupdate)
		tsindex_update(G->tr_xover, nd->in, e->top->t - e->bot->t);
	remove_edge(G, n2->pop, e);
	n2->in = nd->in;
	nd->in->bot = n2;
	remove_event(G, (struct event *)nd->ev);
	free_node(G, (struct node *)nd);

#ifdef DEBUG
	fprintf(stderr, "Leaving function %s, nd=%x, iout=%d\n", __func__, nd, iout);
#endif

}

void insert_coal_node(struct genealogy *G, struct edge *e, struct coal_node *nd)
{
	struct edge *e2;
	int pop;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s, e=%x, nd=%x(%d, %.6f)\n", __func__, e, nd, nd->type, nd->t);
#endif
	pop = e->bot->pop;
	e2 = alloc_edge(G, (struct node *)nd, e->bot);
//	if(e->bot->type == NODE_XOVER){	// This case occur when a new lineage created by recombination is absorbed back to old lineage.
//		AS_XOVER_NODE(e->bot)->in = e2;
//
//	}else{
//		e->bot->in = e2;
//	}

//	else if(e->bot->type == NODE_MIGR)
//		((struct migr_node *)e->bot)->in = e2;

//	else if(e->bot->type == NODE_SAM)
//		((struct sam_node *)e->bot)->in = e2;

	nd->out[0] = e2;
	e2->itop = 0;
	nd->in = e;
	e->bot = e2->top = (struct node *)nd;
	add_edge(G, pop, e2);
}

void insert_migr_node(struct genealogy *G, struct edge *e, struct migr_node *nd)
{
	struct edge *e2;
	int pop;

	pop = e->bot->pop;
	e2 = alloc_edge(G, (struct node *)nd, e->bot);
//	if(e->bot->type == NODE_XOVER){
//		AS_XOVER_NODE(e->bot)->in_new = e2;

//	}else{
		e->bot->in = e2;	// If node below e is XOVER, e is a new lineage from xover node, which corresponds to e->in (see definition of struct node and struct xover_node).
//	}

//	if(e->bot->type == NODE_SAM)
//		((struct sam_node *)e->bot)->in = e2;

//	else if(e->bot->type == NODE_COAL)
//		((struct coal_node *)e->bot)->in = e2;

//	else if(e->bot->type == NODE_MIGR)
//		((struct migr_node *)e->bot)->in = e2;

	e->bot = e2->top = (struct node *)nd;
	nd->in = e;
	nd->out = e2;
	add_edge(G, pop, e2);
}

/* Erase dangling lineage until a coalescent node is reached. */
void erase_dangling2(struct genealogy *G, struct edge *e)
{
	struct config *cfg;
	struct migr_node *nm;
	int pop;

#ifdef DEBUG
	fprintf(stderr, "Entering %s\n", __func__);
#endif

	pop = e->bot->pop;
	while(e->top->type == NODE_MIGR){
		nm = (struct migr_node *)e->top;
#ifdef DEBUG
		fprintf(stderr, "%d: e=%x, n=%x, n->t=%.6f, n->type=%d\n", __LINE__, e, nm, nm->t, nm->type);
#endif

		remove_edge(G, pop, e);
//		e->bdeleted = 1;
//		free_edge(G, e);
		e = nm->in;
		pop = e->bot->pop;
		if(((struct event *)nm->ev)->type == EVENT_MIGR)// MIGR node may be generated by SPLT event. In this case, the event cannot be removed.
			remove_event(G, (struct event *)nm->ev);
		free_node(G, (struct node *)nm);
	}

	/* If the erased lineage is below localMRCA, then move down localMRCA. */
	if(e->top == G->root){
		remove_event(G, (struct event *)e->top->ev);
		free_node(G, e->top);
		G->root = G->localMRCA = NULL;

	}else if(e->top == G->localMRCA){
		struct coal_node *mrca;
		struct migr_node *nm;
		struct node *nbot, *ntop;
		struct edge *ebelow;

		mrca = (struct coal_node *)G->localMRCA; // In this case, root must be coalescent node */
		ntop = G->localMRCA;
		ebelow = mrca->out[1 - e->itop];
#ifdef DEBUG
		fprintf(stderr, "%s: %d:\n", __func__, __LINE__);
#endif

		/* Move downward along another branch to find new root. */
/*		do{
			nbot = ebelow->bot;
			tsindex_clear(G->tr_xover, ebelow);
			list_remove(&G->e_list, ebelow);
			ntop = nbot;
			if(nbot->type == NODE_MIGR){
				ebelow = AS_MIGR_NODE(nbot)->out;
			}
		}while(nbot->type == NODE_MIGR);
		G->localMRCA = nbot;*/

		/* Move downward along another branch to find new root. */
		ntop = ebelow->bot;
		while(ntop->type == NODE_MIGR){
			struct edge *ebelow2;
			ebelow2 = AS_MIGR_NODE(ntop)->out;
			tsindex_clear(G->tr_xover, ebelow2);
			list_remove(&G->e_list, ebelow2);
			ntop = ebelow2->bot;
		}
		G->localMRCA = ntop;

		// The edge above removed coalescent node is not in local genealogy, so we do not need to update tsindex. */
		remove_coal_node(G, (struct coal_node *)e->top, e->itop, 0);

	}else{
		// The edge above removed coalescent node is in local genealogy, so tsindex need to be updated. */
		remove_coal_node(G, (struct coal_node *)e->top, e->itop, 1);
	}

	remove_edge(G, pop, e);
#ifdef DEBUG
	fprintf(stderr, "%s finisned\n", __func__);
#endif

//	list_remove(&G->e_list, e);
//	e->bdeleted = 1;
}

struct edge *pick_ith_tedge(struct list_head *E, int i, double t)
{
	struct list_head *el;
	struct edge *e;
	int j;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s: i=%d, t=%.6f\n", __func__, i, t);
#endif
	j = 0;
	el = E;
	while(el){
		e = (struct edge *)GET_OBJ(el);
		if(e->bot->t < t && t < e->top->t)
			j++;

#ifdef DEBUG
		fprintf(stderr, "->[%d, %x, %x(%d, %.6f), %x(%d, %.6f)]", j, e, e->bot, e->bot->type, e->bot->t, e->top, e->top->type, e->top->t);
#endif
		if(j > i){
#ifdef DEBUG
			fprintf(stderr, "\n");
			fprintf(stderr, "%x(%x) is chosen, range=[%.6f, %.6f]\n\n", e, el, e->bot->t, e->top->t);
#endif
			return e;

		}else{
			el = el->next;
		}
	}

#ifdef DEBUG
	fprintf(stderr, "\n");
	fprintf(stderr, "%x is chosen\n\n", NULL);
#endif
	return NULL;
}

/* MaCS-like procedure for choosing coalescing edge. */
struct edge *choose_tedge(struct genealogy *G, struct population *pop, double t)
{
	struct edge *e;
	int found;

	e = NULL;
	found = 0;
	while(!found){
		int u;

		u = pop->nedges * dunif01();
		e = pop->eptrs[u];
//		if(e == NULL){

		if(e){
/*			if(e->bdeleted){
				void *l;
				int *pidx;

				if(!e->inqueue){
					l = malloc(sizeof(struct list_head) + sizeof(int));
					pidx = l + sizeof(struct list_head);
					*pidx = u;
					__list_append(&pop->idx_queue, l);
					e->inqueue = 1;
				}

			}
			else */if(e->bot->t < t && e->top->t > t){	// An edge spanning t is found
				found = 1;
			}
		}
	}
//if(G->cfg->debug)
//fprintf(stderr, "absorption time=%.10f, coal_edge=(%.10f, %.10f)\n", t, e->bot->t, e->top->t);
	return e;
}

/*struct edge *choose_tedge(struct genealogy *G, struct list_head *E, int n, double t)
{
	int c;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s: n=%d, t=%.6f\n", __func__, n, t);
#endif
	c = dunif(n);
	return pick_ith_tedge(E, c, t);
}*/

/* Absorb floating lineage f into e. */
#ifdef DEBUG
int nabs = 0;
#endif
struct event *__absorption(struct genealogy *G, struct edge *e, struct edge *f, int pop, double t)
{
	struct coal_event *ev;
	struct coal_node *nd;

#ifdef DEBUG
//	nabs++;
	fprintf(stderr, "Entering function %s: e=%x, f=%x, pop=%d, t=%.6f\n", __func__, e, f, pop, t);
#endif
	nd = (struct coal_node *)alloc_node(G, NODE_COAL, pop, t);

	if(t > G->localMRCA->t){
		struct list_head *l;
		struct edge *e2;
		int change;

		struct edge *edum;
		struct node *ndum, *n;

#ifdef DEBUG
		fprintf(stderr, "e->bot == G->root!!\n");
#endif
//		change = 0;
//		if(G->root->pop != pop){
//			change = 1;
//			remove_edge(G, G->root->pop, e);
//		}

//		Add dummy edges into in-tree edge list
		edum = G->localMRCA->in;
		ndum = edum->top;
		while(ndum->t < t){
			tsindex_add(G->tr_xover, edum);
			list_add(&G->e_list, edum);
			edum = ndum->in;
			ndum = edum->top;
		}

		// The edge above nd is dangling, so tsindex need not to be updated.
		insert_coal_node(G, e, nd);
		G->localMRCA = (struct node *)nd;

//		if(change)
//			add_edge(G, pop, e);

	}else{
		tsindex_update(G->tr_xover, e, -(t - e->bot->t));
		insert_coal_node(G, e, nd);
	}

	/* Set up another (absorbed) branch below the new coalescent node. */
	nd->out[1] = f;
	free_node(G, f->top);
	f->top = (struct node *)nd;
	f->itop = 1;
	ev = (struct coal_event *)alloc_event(G->cfg, EVENT_COAL, t);
	ev->pop = pop;
	nd->ev = ev;

	add_edge(G, pop, f);

//	G->localMRCA = (struct node *)nd;

#ifdef DEBUG
	fprintf(stderr, "Finishing function %s\n", __func__);
#endif

	return (struct event *)ev;
}

// This must be called from merge_floating
struct event *absorption(struct genealogy *G, struct edge *f, int pop, double t)
{
	struct edge *e, *e_new;
	struct event *ev;
	double tmrca_old;

	tmrca_old = G->root->t;
/*	if(t > tmrca_old){
		struct node *nf;
		nf = alloc_node(G, NODE_FLOAT, pop, INFINITY);
		e = alloc_edge(G, nf, G->root);
		G->root->in = e;

	}else{*/
		e = choose_tedge(G, &G->pops[pop], t);
//	}
	ev = __absorption(G, e, f, pop, t);
	e_new = AS_COAL_NODE(e->bot)->out[0];	// Get the new edge allocated by insert_coal_node (Old lineage below coalescent node).
	e_new->bot->in = e_new;	// Because this function is called by merge_floating, e_new->bot cannot be XOVER node

/*	if(t > tmrca_old){
		free_node(G, e->top);
		free_edge(G, e);
		G->root->in = NULL;
	}*/
	return ev;
}

void pick2(int n, int *i, int *j)
{
	*i = dunif(n) ;
	while( ( *j = dunif(n) ) == *i );
}

int ncoal = 0;
struct event *coalescent( struct genealogy *G, struct list *F, int pop, double t)
{
	struct coal_event *ev;
	struct edge *e1, *e2, *e_new;
	struct coal_node *nd;
	struct list_head *l;
	int c1, c2;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	ncoal++;
	pick2(F[pop].n, &c1, &c2);

/*	pop = 0;
	t = 0.00028369917921343006;
	c1 = 2;
	c2 = 0;*/
#ifdef DEBUG
	fprintf(stderr, "ncoal=%d, pop=%d, c1=%d, c2=%d, nF[%d]=%d\n", ncoal, pop, c1, c2, pop, F[pop].n);
#endif
/*if(G->cfg->debug){
fprintf(stderr, "Coalescent edges: iChr1=%d, iChr2=%d\n", c1, c2);
l = F[pop].front;
while(l){
	struct edge *e = (struct edge *)GET_OBJ(l);
	struct node *n = e->bot;

	if(n->type == NODE_COAL){
		fprintf(stderr, "%.10f,", n->t);

	}else if(n->type == NODE_SAM){
		struct sam_node *sn = (struct sam_node *)n;
		fprintf(stderr, "%d,", sn->fg->id);
	}
	l = l->next;
}
fprintf(stderr, "\n");
}*/

	{
		struct edge **ep1, **ep2;
		int *cp1, *cp2, i;
		if(c1 > c2){
			cp1 = &c2;
			ep1 = &e2;
			cp2 = &c1;
			ep2 = &e1;
		}else{
			cp1 = &c1;
			ep1 = &e1;
			cp2 = &c2;
			ep2 = &e2;
		}

		l = F[pop].front;
		for(i = 0; i < *cp1; i++) l = l->next;
		*ep1 = (struct edge *)GET_OBJ(l);
		for(; i < *cp2; i++) l = l->next;
		*ep2 = (struct edge *)GET_OBJ(l);
	}

//	e1 = pick_ith_tedge(F[pop].front, c1, t);
//	e2 = pick_ith_tedge(F[pop].front, c2, t);

	nd = (struct coal_node *)alloc_node(G, NODE_COAL, pop, t);
	free_node(G, e2->top);

	// Note that edge above nd must be floating and not in local genealogy.
	insert_coal_node(G, e1, nd);

	e_new = nd->out[0];
	e_new->bot->in = e_new;	// Because this function is called by merge_floating, e_new->bot cannot be XOVER node.

	/* Set up another branch below the coalescent node */
	nd->out[1] = e2;
	e2->itop = 1;
	e2->top = (struct node *)nd;
	list_remove(&F[pop], e1);
	list_append(&F[pop], e1);

	list_remove(&F[pop], e2);
	add_edge(G, pop, e2);

	ev = (struct coal_event *)alloc_event(G->cfg, EVENT_COAL, t);
	ev->pop = pop;

	nd->ev = ev;

#ifdef DEBUG
	fprintf(stderr, "c1=%d, c2=%d, e1->bot=%x, e1->bot->type=%d, e2->bot=%x, e2->bot->type=%d\n", c1, c2, e1->bot, e1->bot->type, e2->bot, e2->bot->type);
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif

	return (struct event *)ev;
}

/* Migrate single floating lineage. */
int nmigr = 0;
struct migr_node *do_migrate(struct genealogy *G, struct edge *e, int dpop, int spop, double t)
{
	struct migr_event *ev;
	struct migr_node *nd;
	struct list_head *l;
	double u;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	nmigr++;
#ifdef DEBUG
	fprintf(stderr, "Moving lineage %x(%x) from population %d to %d\n", e, GET_LIST(e), dpop, spop);
#endif
	nd = (struct migr_node *)alloc_node(G, NODE_MIGR, spop, t);

	// The edge above nd must be floating
	insert_migr_node(G, e, nd);

/*	ev = (struct migr_event *)alloc_event(G->cfg, EVENT_MIGR, t);
	ev->dpop = dpop;
	ev->spop = spop;*/
	((struct dummy_node *)e->top)->pop = spop;

/*	nd->ev = ev;*/

#ifdef DEBUG
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
	return nd;
}

struct migr_event *__migration(struct genealogy *G, struct edge *e, int dpop, double t)
{
	struct config *cfg;
	struct migr_event *ev;
	struct migr_node *nd;
	struct list_head *l;
	double u, sum;
	int spop;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	cfg = G->cfg;
	nmigr++;
	// Generate source population (in forward-time sense) at random
	u = dunif01() * G->pops[dpop].mrate[dpop];
	sum = 0;
	for(spop = 0; spop < cfg->npop + cfg->nsplt; spop++){
		if(spop != dpop && G->pops[spop].enabled){
			sum += G->pops[dpop].mrate[spop];
		}
		if(u < sum)
			break;
//		else
//			u -= G->pops[dpop].mrate[spop] / G->pops[dpop].mrate[dpop];
	}
#ifdef DEBUG
	fprintf(stderr, "Moving lineage %x(%x) from population %d to %d at time %.10f\n", e, GET_LIST(e), dpop, spop, t);
#endif
	nd = do_migrate(G, e, dpop, spop, t);

	ev = (struct migr_event *)alloc_event(G->cfg, EVENT_MIGR, t);
	ev->dpop = dpop;
	ev->spop = spop;

	nd->ev = ev;

#ifdef DEBUG
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
	return ev;
}

/* Choose one from a set of floating lineage and perform migration. */
/*struct migr_event *migration(struct genealogy *G, struct list *F, int dpop, double t)
{
	struct migr_event *ev;
	struct list_head *l;
	struct edge *e;
	int c;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	c = dunif(F[dpop].n);
	e = pick_ith_tedge(F[dpop].front, c, t);
	list_remove(&F[dpop], e);
	ev = __migration(G, e, dpop, t);
//	fprintf(stdout, "nmigr=%d, dpop=%d, c=%d, ev->dpop=%d, ev->spop=%d\n", nmigr, dpop, c, ev->dpop, ev->spop);
	list_add(&F[ev->spop], e);

#ifdef DEBUG
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
	return ev;
}*/

void build_trunk_e(struct genealogy *G, int lb)
{
	struct config *cfg;
	struct list_head *nl, *next;
	int pop;

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s, lb=%d\n", __func__, lb);
#endif
	nl = G->n_list.front;
	while(nl){
		struct sam_node *nd;

		next = nl->next;
		nd = (struct sam_node *)GET_OBJ(nl);
#ifdef DEBUG
		fprintf(stderr, "node=%x, frag end=%d\n", nd, nd->fg->end);
#endif
		if(nd->fg->end <= lb && nd->fg->trunk == 0){
//		if(nd->fg->end <= lb){

			struct edge *e;
#ifdef DEBUG
			fprintf(stderr, "Finishing node %x (fragment %d)\n", nd, nd->fg->id);
#endif
			G->nsam--;
			G->pops[nd->pop].nsam--;
			__list_remove(&G->n_list, nl);
			e = nd->in;
/*			if(nd == (struct sam_node *)G->localMRCA){	// If last region does not overlap with current region. Note that root is sample node only if there is only one genealogy in G
#ifdef DEBUG
				fprintf(stderr, "%x is root!!\n", nd);
#endif
				remove_edge(G, e->bot->pop, e);
//				list_remove(&G->e_list, e);
//				e->bdeleted = 1;
//				free_node(G, e->top);
//				remove_edge(G, nd->pop, e);
//				free_edge(G, e);

				G->localMRCA = G->root = NULL;

			}else{*/
#ifdef DEBUG
				fprintf(stderr, "Erasing finished lineage.\n");
#endif
				erase_dangling2(G, e);
//			}
			free_node(G, (struct node *)nd);
		}
		nl = next;
	}
#ifdef DEBUG
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
}

/* Modify population configuration according to an event. */
void do_event(struct genealogy *G, struct event *ev)
{
	int pop, all_pops, i, j;

	all_pops = G->cfg->npop + G->cfg->nsplt;
#ifdef DEBUG
	fprintf(stderr, "%s: (%d, %.6f", __func__, ev->type, ev->t);
#endif
//	for(pop = 0; pop < all_pops; pop++)
//		if(G->pops[pop].grate != 0)
//			G->pops[pop].size *= exp(-G->pops[pop].grate * (ev->t - G->tlast));

	if(ev->type == EVENT_COAL){
#ifdef DEBUG
		fprintf(stderr, ", pop=%d", ((struct coal_event *)ev)->pop);
#endif
		G->pops[((struct coal_event *)ev)->pop].n--;

	}else if(ev->type == EVENT_MIGR){
#ifdef DEBUG
		fprintf(stderr, ", dpop=%d, spop=%d", ((struct migr_event *)ev)->dpop, ((struct migr_event *)ev)->spop);
#endif
		G->pops[((struct migr_event *)ev)->dpop].n--;
		G->pops[((struct migr_event *)ev)->spop].n++;

	}else if(ev->type == EVENT_GROW){
		int epop;

		epop = ((struct grow_event *)ev)->pop;
		G->pops[epop].size *= exp(-G->pops[epop].grate * (ev->t - G->pops[epop].tlast));
		G->pops[epop].tlast = ev->t;
		G->pops[epop].grate = ((struct grow_event *)ev)->alpha;

	}else if(ev->type == EVENT_SIZE){	/* Change size of a subpopulation */
		G->pops[((struct size_event *)ev)->pop].size = ((struct size_event *)ev)->size;

	}else if(ev->type == EVENT_RMIG){	/* Modify migration rate from subpopulation i to subpopulation j. */
		struct rmig_event *rev = (struct rmig_event *)ev;
		G->pops[rev->popi].mrate[rev->popj] = rev->rmig;

	}else if(ev->type == EVENT_GMIG){	/* Change migration rate. */
		double mig_rate;
		int npop;

		mig_rate = ((struct gmig_event *)ev)->rmig;

		npop = 0;
		for(i = 0; i < all_pops; i++)
			npop += (G->pops[i].enabled != 0);

		for(i = 0; i < all_pops; i++){
			if(G->pops[i].enabled){
				for(j = 0; j < all_pops; j++){
					if(G->pops[j].enabled){
						if(i == j){
							G->pops[i].mrate[j] = mig_rate;

						}else{
							G->pops[i].mrate[j] = mig_rate / (npop - 1);
						}
					}
				}
			}
		}

	}else if(ev->type == EVENT_GSIZ){	/* Change size of all subpopulations. */
		for(i = 0; i < all_pops; i++)
			if(G->pops[i].enabled)
				G->pops[i].size = ((struct gsiz_event *)ev)->size;

	}else if(ev->type == EVENT_GGRO){	/* Change growth rate of all subpopulations. */
		for(i = 0; i < all_pops; i++){
			if(G->pops[i].enabled){
				G->pops[i].size *= exp(-G->pops[i].grate * (ev->t - G->pops[i].tlast));
				G->pops[i].tlast = ev->t;
				G->pops[i].grate = ((struct ggro_event *)ev)->alpha;
			}
		}

	}else if(ev->type == EVENT_JOIN){	/* Population join */
		struct join_event *jev;

		jev = (struct join_event *)ev;
		G->pops[jev->popj].enabled = 0;
		for(i = 0; i < all_pops; i++)
			if(i != jev->popj)
				G->pops[i].mrate[jev->popj] = 0;

		for(i = 0; i < all_pops; i++){
			G->pops[i].mrate[i] = 0;
			for(j = 0; j < all_pops; j++)
				if(i != j)
					G->pops[i].mrate[i] += G->pops[i].mrate[j];
		}

		G->pops[jev->popi].n += G->pops[jev->popj].n;
		G->pops[jev->popj].n = 0;

	}else if(ev->type == EVENT_SPLT){	/* Population split */
		struct splt_event *sev;
		int pop, newpop;

		sev = (struct splt_event *)ev;
		pop = sev->pop;
		newpop = sev->newpop;
		G->pops[sev->newpop].enabled = 1;
		G->pops[sev->newpop].size = G->pops[sev->pop].size;
		G->pops[sev->newpop].grate = 0;

		for(i = 0; i < G->pops[pop].nedges; i++){
			/* Count the number of lineages that move to new population. */
			if(G->pops[pop].eptrs[i] && G->pops[pop].eptrs[i]->top->ev == ev){
				G->pops[pop].n--;
				G->pops[newpop].n++;
			}
		}
	}
#ifdef DEBUG
	fprintf(stderr, ")\n");
#endif
}

struct event *trace_event(struct genealogy *G, double t)
{
	struct list_head *evl;
	struct event *ev;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s, t=%.6f\n", __func__, t);
#endif
	evl = G->evlist->front;
	ev = (struct event *)GET_OBJ(evl);
#ifdef DEBUG
	fprintf(stderr, "->[%x, %x, %d, %.6f]", evl, ev, ev->type, ev->t);
#endif
	while(evl && ev->t < t){
		do_event(G, ev);
		evl = evl->next;
		ev = (struct event *)GET_OBJ(evl);
#ifdef DEBUG
		fprintf(stderr, "->[%x, %x, %d, %.6f]", evl, ev, ev->type, ev->t);
#endif
	}
#ifdef DEBUG
	fprintf(stderr, "\n");
#endif
	return ev;
}

/* Calculate total branch length */
double L(struct genealogy *G)
{
	double total;

	total = tsindex_size(G->tr_xover);

	return total;
}

void reset_populations(struct genealogy *G)
{
	struct config *cfg;
	int pop, i;

	cfg = G->cfg;
	/* Reset populations existing at time 0. */
	for(pop = 0; pop < cfg->npop; pop++){
		G->pops[pop].n = G->pops[pop].nsam;
		G->pops[pop].grate = cfg->grate[pop];
		G->pops[pop].size = cfg->size[pop];
		for(i = 0; i < cfg->npop; i++)
			G->pops[pop].mrate[i] = cfg->mmig[pop][i];

		for(; i < cfg->npop + cfg->nsplt; i++)
			G->pops[pop].mrate[i] = 0;
	}

	/* Reset populations created by splt event. */
	for(;pop < cfg->npop + cfg->nsplt; pop++){
		G->pops[pop].n = 0;
		G->pops[pop].grate = 0;
		G->pops[pop].size = 0;
		G->pops[pop].tlast = 0;
		memset(G->pops[pop].mrate, 0, sizeof(double) * (cfg->npop + cfg->nsplt));
	}
}

/* Select a point uniformly on G. Note that selected point must be below root.
 * The event next to the new event time will be returned. */
struct event *rnd_select_point(struct genealogy *G, struct edge **eo, int *popo, double *to)
{
	struct list_head *evl, *l;
	struct event *ev;
	struct edge *e;
	int i, n, c;
	double g, t, running, tsplt, len;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif

	/* Generate a point on the genealogy. */
	g = G->total * dunif01();
//fprintf(stderr, "%d: g=%.10f, G->total=%.10f", __LINE__, g, G->total);

#ifdef DEBUG
	fprintf(stderr, "g=%.6f\n", g);
#endif
	/* Change on 2018/05/13: Search a a random point on current local genealogy by searching binary indexed tree. */
	e = tsindex_search(G->tr_xover, g, &running);

output:
	*eo = e;
	*popo = e->bot->pop;
	*to = tsplt = e->bot->t + g - running;
//if(G->cfg->debug)
//fprintf(stderr,"recombination time=%.10f, g=%.10f, select=(%.10f, %.10f)\n", tsplt, g, e->bot->t, e->top->t);

	/* Traverse event list until *too. */
	reset_populations(G);

#ifdef DEBUG
	fprintf(stderr, "g=%.6f\n", g);
#endif
	/* Compute real time point. */
	t = 0;
	evl = G->evlist->front;
	ev = (struct event *)GET_OBJ(evl);
	while(ev->t <= tsplt){
		t = ev->t;
		do_event(G, ev);
		evl = evl->next;
		ev = (struct event *)GET_OBJ(evl);
	}

	return ev;
}

void create_floating(struct genealogy *G, struct list *R, struct list *F)
{
	struct list_head *rl, *l;
	int i;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif

	rl = R->front;
	while(rl){
		struct sam_node *n1;
		struct dummy_node *n2;
		struct frag *r;
		struct edge *e;

		r = *((struct frag **)GET_OBJ(rl));
		n1 = (struct sam_node *)alloc_node(G, NODE_SAM, r->pop, 0);
		n2 = (struct dummy_node *)alloc_node(G, NODE_FLOAT, r->pop, INFINITY);
		e = alloc_edge(G, (struct node *)n2, (struct node *)n1);
		n1->in = n2->out = e;
		n1->fg = r;

		list_append(&F[r->pop], e);
//		list_add(&F[r->pop], e);


		rl = rl->next;
	}

#ifdef DEBUG
	for(i = 0; i < G->cfg->npop; i++){
		l = F[i].front;
		fprintf(stderr, "Subpopulation %d:", i);
		while(l){
			struct sam_node *n1;
			struct edge *e;

			e = (struct edge *)GET_OBJ(l);
			n1 = (struct sam_node *)e->bot;
			fprintf(stderr, "->%x[prev=%x, next=%x, sam_node=%x, dummy_node=%x, edge=%x, fg=%x]", l, l->prev, l->next, n1, e->top, e, n1->fg);
			l = l->next;
		}
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
}

double abs_time(struct genealogy *G, int nF, int pop, double t)
{
	double size, alpha, tlast, r, u, dt;

	size = G->pops[pop].size;
	alpha = G->pops[pop].grate;
	tlast = G->pops[pop].tlast;
//	u = dunif01();
//	ulast = u;
	if(alpha == 0){
		dt = dexp(2 * nF * G->pops[pop].n / size);
//		r = -size * log(u) / (2 * nF * G->pops[pop].n);

	}else{
		u = dunif01();
//		rate = 2 * nF * G->pops[pop].n / (size * exp(alpha * tlast));
		r = 1 - alpha * size * exp(-alpha * (t - tlast)) * log(u) / (2 * nF * G->pops[pop].n);
		dt = log(r) / alpha;
	}
//	fprintf(stderr, "%d: abs_time=%.10f, rate=%.10f, nF=%d, G->pops[%d].n=%d\n", __LINE__, dt, rate, nF, pop, G->pops[pop].n);
	return dt;
}

double coal_time(struct genealogy *G, int nF, int pop, double t)
{
	double size, alpha, tlast, r, u, dt;

	size = G->pops[pop].size;
	alpha = G->pops[pop].grate;
	tlast = G->pops[pop].tlast;

//	u = dunif01();
	if(alpha == 0){
//		rate = nF * (nF - 1) / size;
		dt = dexp(nF * (nF - 1) / size);
//		return -size * log(u) / (nF * (nF - 1));

	}else{
		u = dunif01();
//		rate = nF * (nF - 1) / (size * exp(alpha * tlast));
		r = 1 - alpha * size * exp(-alpha * (t - tlast)) * log(u) / (nF * (nF - 1));
		dt = log(r) / alpha;
//		return 1 - size * exp(alpha * tlast) * log(u) / (nF * (nF - 1));
	}

//	fprintf(stderr, "%d: coal_time=%.10f, rate=%.10f, nF=%d, G->pops[%d].n=%d\n", __LINE__, dt, rate, nF, pop, G->pops[pop].n);
	return dt;
}

/* Remove crossover node and prune old edge above it. */
void remove_xover_node(struct genealogy *G, struct xover_node *nd)
{
	struct edge *e_old, *e_new, *e_below;

	e_old = nd->in;
	e_new = nd->in_new;
	e_below = nd->out;

	erase_dangling2(G, e_old);

	e_new->bot = e_below->bot;
	e_new->bot->in = e_new;
//	e_below->bdeleted = 1;
	remove_edge(G, e_below->bot->pop, e_below);
	free_node(G, (struct node *)nd);
}

double merge_floating(struct genealogy *G, struct list *F);

/* Generate recombination point and modify genealogy */
double recombination(struct genealogy *G)
{
	struct config *cfg;
	int pop, coalesced, i;	// coalesced: flag indicating whether floating lineage is absorbed
	struct list_head *evl, *l;
	struct event *ev;
	struct edge *e, *ef;	// e: edge where recombination event occur
	struct dummy_node *nf;
	double t, like;

	struct edge *e_below_xover, *e4, *e5;	// For simulating behavior of macs
	struct xover_node *nxover;

	cfg = G->cfg;
	/* Choose recombination point at random. */
	ev = rnd_select_point(G, &e, &pop, &t);

//	ev = trace_event(G, t);
	evl = GET_LIST(ev);

#ifdef DEBUG
	fprintf(stderr, "Recombination on %x, t=%.6f, pop=%d, range=[%x(%d, %.6f), %x(%d, %.6f)]\n", e, t, pop, e->bot, e->bot->type, e->bot->t, e->top, e->top->type, e->top->t);
	fprintf(stderr, "%d:", __LINE__);
	for(i = 0; i < cfg->npop + cfg->nsplt; i++)
		fprintf(stderr, ",G->pops[%d].n=%d, G->pops[%d].enabled=%d", i, G->pops[i].n, i, G->pops[i].enabled);
	fprintf(stderr, "\n");
	fprintf(stderr, "Next event: evl=%x, ev=%x, type=%d, t=%6f\n", evl, ev, ev->type, ev->t);
#endif

	/* Generate recombination node */
	nxover = (struct xover_node *)alloc_node(G, NODE_XOVER, pop, t);

	/* Insert recombination node into target edge. */
	e_below_xover = alloc_edge(G, (struct node *)nxover, e->bot);
//	add_edge(G, pop, e_below_xover);
	e->bot = (struct node *)nxover;
	nxover->in = e;
	nxover->out = e_below_xover;

	/* Remove recombinant lineage from the genealogy. */
	nf = (struct dummy_node *)alloc_node(G, NODE_FLOAT, pop, INFINITY);
	ef = alloc_edge(G, (struct node *)nf, e->bot);
	nf->out = ef;
	nxover->in_new = ef;
	tsindex_update(G->tr_xover, e, -(e_below_xover->top->t - e_below_xover->bot->t));

	/* Iterate until floating lineage is absorbed. */
	coalesced = 0;
	like = 0;
	do{
		double at, mg, dmig, sublike, totalprob;
		struct list_head *el;

		totalprob = G->pops[pop].n;
		at = abs_time(G, 1, pop, t);
		dmig = G->pops[pop].mrate[pop] * 1;
		if(dmig > 0){
			totalprob += dmig;
			mg = dexp(dmig);
//			mg = -log(dunif01()) / dmig;

		}else{
			mg = INFINITY;
		}

		ev = (struct event *)GET_OBJ(evl);
		if(isinf(at) && isinf(mg) && isinf(ev->t)){
			like = -INFINITY;
			fprintf(stderr, "%d: Infinite time to next event\n", __LINE__);
			exit(-1);

		}else if(t + at < ev->t || t + mg < ev->t){
			struct event *evnew;

			if(at < mg){		//Next event is absorption
				struct edge *e2;	// e2: Edge where new absorption event occur, e_old: the old branch from xover node
				struct migr_node *n;
				double tmrca_old;

				tmrca_old = G->localMRCA->t;
				sublike = -totalprob * at;
				t += at;
/*				if(t > tmrca_old){
					struct node *nf;
					nf = alloc_node(G, NODE_FLOAT, pop, INFINITY);
					e2 = alloc_edge(G, nf, G->root);
					G->root->in = e2;

				}else{*/
					e2 = choose_tedge(G, &G->pops[pop], t);
//				}

#ifdef DEBUG
				fprintf(stderr, "%d: Absorb floating lineage %x to %x, e=%x\n", __LINE__, ef, e2, e);
#endif

				evnew = __absorption(G, e2, ef, pop, t);

				list_insbefore(evl, evnew);

				if(e2 == e){	// Floating lineage is absorbed to the same lineage (loop in ARG)
					struct edge *e_old;

					nxover->in = AS_COAL_NODE(e2->bot)->out[0];
					e_old = nxover->in;

//					// e_old->top is the new coalescent node which has to be removed. In this case, e2 must be in local genealogy, so tsindex must be updated
					remove_coal_node(G, AS_COAL_NODE(e_old->top), e_old->itop, 1);
					remove_edge(G, pop, e_old);

				}else{
					struct edge *e_new;	// The new edge allocated by insert_coal_node

					e_new = AS_COAL_NODE(e2->bot)->out[0];
					e_new->bot->in = e_new;
					erase_dangling2(G, nxover->in);
				}

				{
					struct edge *e_new, *e_below;

					e_new = nxover->in_new;
					e_below = nxover->out;
					tsindex_update(G->tr_xover, e_new, e_below->top->t - e_below->bot->t);
					e_new->bot = e_below->bot;
					e_new->bot->in = e_new;
//					remove_edge(G, e_below->bot->pop, e_below);
					free_edge(G, e_below);
					free_node(G, (struct node *)nxover);
				}

/*				if(t > tmrca_old){
//				if(t > G->root->t){
					free_node(G, e2->top);
					free_edge(G, e2);
					G->root->in = NULL;
				}*/

				coalesced = 1;

			}else{	// Next event is migration
#ifdef DEBUG
				fprintf(stderr, "%d: Next event is migration\n", __LINE__);
#endif
				sublike = log(dmig) - totalprob * mg;
				t += mg;
				evnew = (struct event *)__migration(G, ef, pop, t);
				list_insbefore(evl, evnew);
				G->evlist->n++;
				pop = ((struct migr_event *)evnew)->spop;
			}

			like += sublike;

		}else{
			do_event(G, ev);
			like -= totalprob * (ev->t - t);
			t = ev->t;

			if(ev->type == EVENT_JOIN){
				struct join_event *jev;
				struct migr_node *nd;

				jev = (struct join_event *)ev;
				if(jev->popj == pop){
					/* Force the floating lineage moving from population j to population i */
					nd = (struct migr_node *)do_migrate(G, ef, jev->popj, jev->popi, t);
					nd->ev = (struct migr_event *)ev;

					G->evlist->n++;
					pop = jev->popi;
				}

			}else if(ev->type == EVENT_SPLT){
				struct splt_event *sev;
				double u;

				sev = (struct splt_event *)ev;
				if(sev->pop == pop){
					u = dunif01();
					if(u >= sev->prop){
						struct migr_node *nd;

						/* Move the floating lineage to new population */
						nd = (struct migr_node *)do_migrate(G, ef, sev->pop, sev->newpop, t);
						nd->ev = (struct migr_event *)ev;
						pop = sev->newpop;
					}
				}

			}else if(ev->type == EVENT_DUMY || ev->type == EVENT_DXVR){
				struct list *F;
				struct edge *edum;
				struct node *ndum, *n;
				double troot_old;

				troot_old = G->root->t;

#ifdef DEBUG
				if(ev->type == EVENT_DUMY){
					fprintf(stderr, "%s: %d: DUMY event is found at time %.6f\n", __func__, __LINE__, ev->t);

				}else{
					fprintf(stderr, "%s: %d: DXVR event is found at time %.6f\n", __func__, __LINE__, ev->t);
				}
#endif

				// Move edges in dummy edge list to in-tree edge list until t (Note that edges in dummy edge list are ordered by time)
				edum = G->localMRCA->in;
				ndum = edum->top;
				while(ndum->t < ev->t){
					tsindex_add(G->tr_xover, edum);
					list_add(&G->e_list, edum);
					edum = ndum->in;
					ndum = edum->top;
				}

				// Remove remaining edges in dummy edge list
				if(ev->type == EVENT_DXVR){
					struct edge *erm;
					struct node *nrm;
					int poprm;

					G->ev_dxvr = NULL;
					erm = ndum->in;
					poprm = ndum->pop;
					while(erm){
						nrm = erm->top;
						__remove_edge(G, poprm, erm);
						free_edge(G, erm);
						poprm = nrm->pop;
						remove_event(G, (struct event *)nrm->ev);
						erm = nrm->in;
						free_node(G, nrm);
					}
					nrm = ndum;
					remove_event(G, ndum->ev);
					edum->top = ndum = alloc_node(G, NODE_FLOAT, nrm->pop, INFINITY);
					AS_DUMMY_NODE(ndum)->out = edum;
					AS_DUMMY_NODE(ndum)->in = NULL;
					free_node(G, nrm);
					G->pops[edum->bot->pop].n = 0;

				}else{
					G->pops[G->root->pop].n = 0;
					ndum->ev = NULL;

					// Create new floating lineage
					ndum->type = NODE_FLOAT;
					ndum->t = INFINITY;
				}

				F = malloc(sizeof(struct list) * cfg->npop_all);
				for(i = 0; i < cfg->npop_all; i++)
					list_init(&F[i]);

				__remove_edge(G, edum->bot->pop, edum);
				list_add(&F[edum->bot->pop], edum);
				list_add(&F[pop], ef);
				G->pops[edum->bot->pop].n--;

				G->root = G->localMRCA = NULL;	// localMRCA is cancelled because new local MRCA must be above current root

				G->t = t;
				G->evlcurr = evl->next;
				like += merge_floating(G, F);

				{
					struct edge *e_new, *e_below;

					erase_dangling2(G, nxover->in);

					e_new = nxover->in_new;
					e_below = nxover->out;
					tsindex_update(G->tr_xover, e_new, e_below->top->t - e_below->bot->t);
					e_new->bot = e_below->bot;
					e_new->bot->in = e_new;
//					remove_edge(G, e_below->bot->pop, e_below);
					free_edge(G, e_below);
					free_node(G, (struct node *)nxover);
				}

				free(F);
				coalesced = 1;
			}

			evl = evl->next;
			if(ev->type == EVENT_DUMY || ev->type == EVENT_DXVR)
				remove_event(G, ev);

		}
	}while(!coalesced);

#ifdef DEBUG
	/* Print current population size. */
	fprintf(stderr, "%d: Current population size:[", __LINE__);
	for(i = 0; i < cfg->npop + cfg->nsplt; i++)
		fprintf(stderr, "%.6f,", G->pops[i].size);
	fprintf(stderr, "]\n");

	/* Print current growth rate. */
	fprintf(stderr, "%d: Current growth rate:[", __LINE__);
	for(i = 0; i < cfg->npop + cfg->nsplt; i++)
		fprintf(stderr, "%.6f,", G->pops[i].grate);
	fprintf(stderr, "]\n");

	/* Print current migration matrix. */
	fprintf(stderr, "Current migration matrix:[\n");
	for(i = 0; i < cfg->npop + cfg->nsplt; i++){
		int j;
		for(j = 0; j < cfg->npop + cfg->nsplt; j++)
			fprintf(stderr, "%.6f,", G->pops[i].mrate[j]);
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "]\n");

	fprintf(stderr, "%d:", __LINE__);
	{
		struct list_head *el;
		el = G->e_list.front;
		fprintf(stderr, "Edge list in tree:\n");
		while(el){
			struct edge *et;
			et = (struct edge *)GET_OBJ(el);
			fprintf(stderr, "->[%x, %x, bot=(%x, %d, %.6f), top=(%x, %d, %.6f)]\n", el, et, et->bot, et->bot->type, et->bot->t, et->top, et->top->type, et->top->t);
			el = el->next;
		}
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "Finishing %s\n\n", __func__);
#endif

	return like;
}

double merge_floating(struct genealogy *G, struct list *F)
{
	struct config *cfg;
	struct event *ev, *evnew;
	struct list_head *evl, *f;
	int pop, upop, vpop, zpop, sumnF, i;
	double t, u, minu, v, minv, z, minz;
	double like;

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
//	reset_populations(G);
	evl = G->evlcurr;
//	evl = G->evlist->front;
	t = G->t;
//	t = 0;
	sumnF = 0;
	for(pop = 0; pop < cfg->npop; pop++){
//		G->pops[pop].nsam += F[pop].n;
//		G->nsam += F[pop].n;
		sumnF += F[pop].n;
	}

	like = 0;
	/* If trunk genealogy is not empty, loop until all floating lineages are absorbed.
	   Otherwise, loop until only one floating lineage remained. */
	while((G->root != NULL && sumnF > 0) || (G->root == NULL && sumnF > 1)){
		double totalprob, sublike, rmig;

		totalprob = rmig = 0;
		minu = minv = minz = INFINITY;
		upop = vpop = zpop = 0;
		for(pop = 0; pop < cfg->npop + cfg->nsplt; pop++){
			if(G->pops[pop].n > 0 && F[pop].n > 0){
				u = abs_time(G, F[pop].n, pop, t);
#ifdef DEBUG
				fprintf(stderr, "%d: abs_time=%.10f, nF[%d]=%d, G->pops[%d].n=%d\n", __LINE__, u, pop, F[pop].n, pop, G->pops[pop].n);
#endif
				totalprob += F[pop].n * G->pops[pop].n;

			}else{
				u = INFINITY;
			}

			if(u < minu){
				minu = u;
				upop = pop;
			}
		}

		for(pop = 0; pop < cfg->npop + cfg->nsplt; pop++){
			if(F[pop].n > 0){
				v = coal_time(G, F[pop].n, pop, t);
#ifdef DEBUG
				fprintf(stderr, "%d: coal_time=%.10f, nF[%d]=%d\n", __LINE__, v, pop, F[pop].n);
#endif
				totalprob += F[pop].n * (F[pop].n - 1);

			}else{
				v = INFINITY;
			}

			if(v < minv){
				minv = v;
				vpop = pop;
			}
		}

		rmig = 0;
		for(pop = 0; pop < cfg->npop + cfg->nsplt; pop++){
			rmig += G->pops[pop].mrate[pop] * F[pop].n;
/*			if(rmig > 0){
				z = dexp(rmig);
//				z = -log(dunif01()) / rmig;

				totalprob += rmig;
//fprintf(stderr, "%d: z=%.10f, rmig=%.10f\n", __LINE__, z, rmig);

			}else{
				z = INFINITY;
			}

			if(z < minz){
				minz = z;
				zpop = pop;
			}*/
		}

		if(rmig > 0){
			minz = dexp(rmig);
			totalprob += rmig;

		}else{
			minz = INFINITY;
		}

#ifdef DEBUG
		fprintf(stderr, "%d: Floating lineages:\n", __LINE__);
		for(i = 0; i < cfg->npop; i++){
			struct list_head *l;

			l = F[i].front;
			fprintf(stderr, "Subpopulation %d: n=%d, ", i, F[i].n);
			while(l){
				struct sam_node *n1;
				struct edge *e;

				e = (struct edge *)GET_OBJ(l);
				n1 = (struct sam_node *)e->bot;
				fprintf(stderr, "->%x[prev=%x, next=%x, sam_node=%x, dummy_node=%x, edge=%x, fg=%x]", l, l->prev, l->next, n1, e->top, e, n1->fg);
				l = l->next;
			}
			fprintf(stderr, "\n");
		}

		dump_edges(G);

		fprintf(stderr, "%d:", __LINE__);
		for(i = 0; i < cfg->npop + cfg->nsplt; i++)
			fprintf(stderr, ",G->pops[%d].n=%d, G->pops[%d].enabled=%d", i, G->pops[i].n, i, G->pops[i].enabled);
		fprintf(stderr, "\n");

		/* Print current population size. */
		fprintf(stderr, "%d: Current population size:[", __LINE__);
		for(i = 0; i < cfg->npop + cfg->nsplt; i++)
			fprintf(stderr, "%.6f,", G->pops[i].size);
		fprintf(stderr, "]\n");

		/* Print current growth rate. */
		fprintf(stderr, "%d: Current growth rate:[", __LINE__);
		for(i = 0; i < cfg->npop + cfg->nsplt; i++)
			fprintf(stderr, "%.6f,", G->pops[i].grate);
		fprintf(stderr, "]\n");

		/* Print current migration matrix. */
		fprintf(stderr, "Current migration matrix:[\n");
		for(i = 0; i < cfg->npop + cfg->nsplt; i++){
			int j;
			for(j = 0; j < cfg->npop + cfg->nsplt; j++)
				fprintf(stderr, "%.6f,", G->pops[i].mrate[j]);
			fprintf(stderr, "\n");
		}
		fprintf(stderr, "]\n");

		fprintf(stderr, "%d: t=%.6f, upop=%d, minu=%.6f, vpop=%d, minv=%.6f, zpop=%d, minz=%.6f\n", __LINE__, t, upop, minu, vpop, minv, zpop, minz);
		fprintf(stderr, "sumnF=%d", sumnF);
		for(i = 0; i < cfg->npop + cfg->nsplt; i++)
			fprintf(stderr, ", nF[%d]=%d", i, F[i].n);
		fprintf(stderr, "\n");

#endif

		ev = (struct event *)GET_OBJ(evl);
		if(isinf(minu) && isinf(minv) && isinf(minz) && isinf(ev->t)){
			like = -INFINITY;
			fprintf(stderr, "%d: Infinite time to next event\n", __LINE__);
			exit(-1);
//			return -1;
		}
#ifdef DEBUG
		fprintf(stderr, "%d:", __LINE__);
		for(i = 0; i < cfg->npop + cfg->nsplt; i++)
			fprintf(stderr, ",G->pops[%d].n=%d", i, G->pops[i].n);
		fprintf(stderr, "\n");

		fprintf(stderr, "%d: Next event: evl=%x, ev=%x, type=%d, t=%6f\n", __LINE__, evl, ev, ev->type, ev->t);
#endif

		if(t + minu < ev->t || t + minv < ev->t || t + minz < ev->t){
			struct edge *e;
			int c, i;

			if(minu < minv && minu < minz){	// Absorption
				c = dunif(F[upop].n);
				f = F[upop].front;
				for(i = 0; i < c; i++)
					f = f->next;

				sublike = -totalprob * minu;

				t += minu;
				e = (struct edge *)GET_OBJ(f);
				list_remove(&F[upop], e);
				evnew = absorption(G, e, upop, t);
				sumnF--;

			}else if(minv < minu && minv < minz){	// Coalescent
				t += minv;
				sublike = log(2) - totalprob * minv;
				evnew = coalescent(G, F, vpop, t);
				sumnF--;

			}else{	// Migration
				struct edge *em;
				double sum, x;
				int c;

				t += minz;
				x = rmig * dunif01();

				sum = 0;
				for(zpop = 0; zpop < cfg->npop_all; zpop++){
					for(c = 0; c < F[zpop].n; c++){
						sum += G->pops[zpop].mrate[zpop];
						if(x < sum)
							goto finish_selection;
					}
				}
finish_selection:

				// Find the lineage to be migrated
				em = pick_ith_tedge(F[zpop].front, c, t);
				list_remove(&F[zpop], em);

				/* Perform migration */
				evnew = (struct event *)__migration(G, em, zpop, t);
//				fprintf(stdout, "nmigr=%d, dpop=%d, c=%d, ev->dpop=%d, ev->spop=%d\n", nmigr, dpop, c, ev->dpop, ev->spop);

				list_add(&F[((struct migr_event *)evnew)->spop], em);

				sublike = log(G->pops[zpop].mrate[zpop]) - totalprob * minz;
//				evnew = (struct event *)migration(G, F, zpop, t);
			}

			like += sublike;
			list_insbefore(evl, evnew);
			G->evlist->n++;

		}else{
			do_event(G, ev);
			like -= totalprob * (ev->t - t);
			t = ev->t;

			if(ev->type == EVENT_JOIN){
				struct join_event *jev;
				struct list_head *f;

				/* Force all lineages in population i moving to population j */
				jev = (struct join_event *)ev;
				f = F[jev->popj].front;
				while(f){
					struct list_head *tmp;
					struct migr_node *nd;
					struct edge *e;

					e = (struct edge *)GET_OBJ(f);
					tmp = f->next;
					list_remove(&F[jev->popj], e);
					nd = (struct migr_node *)do_migrate(G, e, jev->popj, jev->popi, t);
					list_append(&F[jev->popi], e);
					nd->ev = (struct migr_event *)ev;

					f = tmp;
				}
//				F[jev->popi].n += F[jev->popj].n;
//				F[jev->popj].n = 0;

			}else if(ev->type == EVENT_SPLT){
				struct splt_event *sev;
				struct list_head *f;

				sev = (struct splt_event *)ev;
				f = F[sev->pop].front;
				while(f){
					struct list_head *tmp;
					struct migr_node *nd;
					struct edge *e;
					double u;

					e = (struct edge *)GET_OBJ(f);
					u = dunif01();
					if(u >= sev->prop){
						list_remove(&F[sev->pop], e);
						nd = (struct migr_node *)do_migrate(G, e, sev->pop, sev->newpop, t);
						list_append(&F[sev->newpop], e);
						nd->ev = (struct migr_event *)ev;
					}
					tmp = f->next;
					f = tmp;
				}

			}else if(ev->type == EVENT_DUMY || ev->type == EVENT_DXVR){
				struct edge *edum;
				struct node *ndum, *n;

#ifdef DEBUG
				if(ev->type == EVENT_DUMY){
					fprintf(stderr, "%s: %d: DUMY event is found at time %.6f\n", __func__, __LINE__, ev->t);

				}else{
					fprintf(stderr, "%s: %d: DXVR event is found at time %.6f\n", __func__, __LINE__, ev->t);
				}
#endif
				sumnF++;

				// Move edges in dummy edge list to in-tree edge list until t (Note that edges in dummy edge list are ordered by time)
				edum = G->localMRCA->in;
				ndum = edum->top;
				while(ndum->t < ev->t){
					tsindex_add(G->tr_xover, edum);
					list_add(&G->e_list, edum);
					edum = ndum->in;
					ndum = edum->top;
				}

				// Remove remaining edges in dummy edge list
				if(ev->type == EVENT_DXVR){
					struct edge *erm;
					struct node *nrm;
					int poprm;

					G->ev_dxvr = NULL;
					erm = ndum->in;
					poprm = ndum->pop;
					while(erm){
						nrm = erm->top;
						__remove_edge(G, poprm, erm);
						poprm = nrm->pop;
						remove_event(G, (struct event *)nrm->ev);
						erm = nrm->in;
						free_node(G, nrm);
					}
					nrm = ndum;
					remove_event(G, ndum->ev);
					edum->top = ndum = alloc_node(G, NODE_FLOAT, nrm->pop, INFINITY);
					AS_DUMMY_NODE(ndum)->out = edum;
					AS_DUMMY_NODE(ndum)->in = NULL;
					free_node(G, nrm);
					G->pops[edum->bot->pop].n = 0;

				}else{
					G->pops[G->root->pop].n = 0;
					ndum->ev = NULL;

					// Create new floating lineage
					ndum->type = NODE_FLOAT;
					ndum->t = INFINITY;
				}


				__remove_edge(G, edum->bot->pop, edum);
				list_add(&F[edum->bot->pop], edum);

				G->root = G->localMRCA = NULL;
			}

			evl = evl->next;
			if(ev->type == EVENT_DUMY || ev->type == EVENT_DXVR)
				remove_event(G, ev);
		}
	}

	if(G->localMRCA == NULL){	// In this case, last event must be coalescent between two floating lineages
		struct node *ndum;
		struct edge *e;

		for(i = 0; i < cfg->npop; i++)
			if(F[i].front)
				break;
		f = F[i].front;
		e = (struct edge *)GET_OBJ(f);
		e->top->type = NODE_DUMMY;
		e->top->t = e->bot->t;
		__add_edge(G, e->bot->pop, e);

		if(G->troot > e->top->t){
			e->top->t = G->troot;

		}else{
			G->troot = e->top->t;
		}

		G->root = e->top;
		G->localMRCA = e->bot;

		evnew = alloc_event(G->cfg, EVENT_DUMY, e->top->t);
		list_insbefore(evl, evnew);
		e->top->ev = evnew;
	}

#ifdef DEBUG
	fprintf(stderr, "%d:", __LINE__);
	for(i = 0; i < cfg->npop + cfg->nsplt; i++)
		fprintf(stderr, ",G->pops[%d].n=%d, G->pops[%d].enabled=%d", i, G->pops[i].n, i, G->pops[i].enabled);
	fprintf(stderr, "\n");

	/* Print current population size. */
	fprintf(stderr, "%d: Current population size:[", __LINE__);
	for(i = 0; i < cfg->npop + cfg->nsplt; i++)
		fprintf(stderr, "%.6f,", G->pops[i].size);
	fprintf(stderr, "]\n");

	/* Print current growth rate. */
	fprintf(stderr, "%d: Current growth rate:[", __LINE__);
	for(i = 0; i < cfg->npop + cfg->nsplt; i++)
		fprintf(stderr, "%.6f,", G->pops[i].grate);
	fprintf(stderr, "]\n");

	/* Print current migration matrix. */
	fprintf(stderr, "Current migration matrix:[\n");
	for(i = 0; i < cfg->npop + cfg->nsplt; i++){
		int j;
		for(j = 0; j < cfg->npop + cfg->nsplt; j++)
			fprintf(stderr, "%.6f,", G->pops[i].mrate[j]);
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "]\n");

	dump_edges(G);

	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
	return like;
//	return 0;
}

void destroy_tree(struct genealogy *G, struct node *nd)
{
	if(nd->type == NODE_COAL){
		struct coal_node *n;

		n = (struct coal_node *)nd;
		remove_event(G, (struct event *)n->ev);
		destroy_tree(G, n->out[0]->bot);
		destroy_tree(G, n->out[1]->bot);
//		n->out[0]->bdeleted = 1;
//		n->out[1]->bdeleted = 1;
//		free_edge(G, n->out[0]);
//		free_edge(G, n->out[1]);

	}else if(nd->type == NODE_MIGR){
		struct migr_node *n;

		n = (struct migr_node *)nd;
		if(n->ev->type == EVENT_MIGR)
			remove_event(G, (struct event *)n->ev);
		destroy_tree(G, n->out->bot);
//		n->out->bdeleted = 1;
//		free_edge(G, n->out);

	}else if(nd->type == NODE_FLOAT || nd->type == NODE_DUMMY){
		struct dummy_node *n;

		n = (struct dummy_node *)nd;
		remove_event(G, (struct event *)n->ev);
		destroy_tree(G, n->out->bot);
//		n->out->bdeleted = 1;
//		free_edge(G, n->out);
	}

	free_node(G, nd);
}

void destroy_pop(struct population *p)
{
	struct list_head *l;
	int i;

	free(p->mrate);
	free(p->eptrs);
}

void clear_genealogy(struct genealogy *G)
{
	struct config *cfg;
	struct list_head *evl, *l;
	struct list *eq;
	int pop, i;

	cfg = G->cfg;
	if(G->root){
//		free_node(G, G->root->in->top);
//		free_edge(G, G->root->in);
		destroy_tree(G, G->root);
		G->root = G->localMRCA = NULL;
	}
	G->total = 0;
	list_init(&G->n_list);

	if(G->ev_dxvr){
		remove_event(G, G->ev_dxvr);
		G->ev_dxvr = NULL;
	}

/*	while(G->e_list.front){
		l = G->e_list.front;
		__list_remove(&G->e_list, l);
		free(l);
	}*/
	tsindex_reset(G->tr_xover);
	list_init(&G->e_list);

	for(pop = 0; pop < cfg->npop + cfg->nsplt; pop++){
		eq = &G->pops[pop].idx_queue;
		while(eq->front){
			l = eq->front;
			__list_remove(eq, l);
			free(l);
		}
		list_init(&G->pops[pop].idx_queue);
		for(i = 0; i < G->pops[pop].nedges; i++){
			if(G->pops[pop].eptrs[i])
				free_edge(G, G->pops[pop].eptrs[i]);
		}
		memset(G->pops[pop].eptrs, 0, sizeof(struct edge *) * G->pops[pop].maxedges);
		G->pops[pop].nedges = 0;
		G->pops[pop].nsam = G->pops[pop].n = 0;
	}
}

struct genealogy *alloc_genealogy(struct config *cfg, struct profile *prof)
{
	int pop, npop, nsplt;
	struct genealogy *G;
	struct list_head *l;

	npop = cfg->npop;
	nsplt = cfg->nsplt;

	G = malloc(sizeof(struct genealogy));
	memset(G, 0, sizeof(struct genealogy));

	G->cfg = cfg;
	G->pops = malloc(sizeof(struct population) * (npop + nsplt));
	memset(G->pops, 0, sizeof(struct population) * (npop + nsplt));
	for(pop = 0; pop < npop + nsplt; pop++){
		G->pops[pop].mrate = malloc(sizeof(double) * (npop + nsplt));
		memset(G->pops[pop].mrate, 0, sizeof(double) * (npop + nsplt));

		if(pop > npop){
			G->pops[pop].enabled = 0;

		}else{
			G->pops[pop].enabled = 1;
		}
		 
		list_init(&G->pops[pop].idx_queue);
		G->pops[pop].eptrs = NULL;
		G->pops[pop].maxedges = G->pops[pop].nedges = 0;
	}
	list_init(&G->n_list);
	list_init(&G->e_list);
	G->evlist = &cfg->evlist;

	/* Set up mutation model of populations that exist at time 0. */
	for(pop = 0; pop < npop; pop++){
		G->pops[pop].mmut = cfg->mmut[pop];
	}

	/* Set up mutation model of populations generated by SPLT event. */
	l = G->evlist->front;
	while(l){
		struct event *ev;
		ev = (struct event *)GET_OBJ(l);
		if(ev->type == EVENT_SPLT){
			struct splt_event *sev;

			sev = (struct splt_event *)ev;
			if(cfg->mmut[sev->newpop] == NULL){	// If user does not specify mutation model of a population that created by SPLT event, then it inherits mutation model of original population
				G->pops[sev->newpop].mmut = cfg->mmut[sev->pop];

			}else{
				G->pops[sev->newpop].mmut = cfg->mmut[sev->newpop];
			}
		}
		l = l->next;
	}

	G->tr_xover = tsindex_alloc(cfg->maxfrag * 2 * 2);

	return G;
}

void destroy_genealogy(struct genealogy *G)
{
	struct config *cfg;
	struct list_head *evl;
	int pop;

	tsindex_free(G->tr_xover);
	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	if(G->root){
#ifdef DEBUG
		fprintf(stderr, "root=%x\n", G->root);
#endif
//		free_node(G, G->root->in->top);
//		free_edge(G, G->root->in);
		destroy_tree(G, G->root);
	}

	for(pop = 0; pop < cfg->npop + cfg->nsplt; pop++)
		destroy_pop(&G->pops[pop]);
	free(G->pops);

//	while(G->evlist->front)
//		remove_event(G, (struct event *)GET_OBJ(G->evlist->front));
//	list_init(G->evlist);

	free(G);
#ifdef DEBUG
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
}

void print_tree(FILE *out_fp, struct node *nd)
{
	if(nd->type == NODE_SAM){
#ifdef DEBUG
		fprintf(stderr, "sam_node=%x;edge=%x", nd, nd->in);
#else
		fprintf(out_fp, "%d", AS_SAM_NODE(nd)->fg->id);
//		fprintf(out_fp, "%d_%d", AS_SAM_NODE(nd)->fg->id, nd->in->id);
#endif
	}else if(nd->type == NODE_COAL){
		struct node *n1, *n2;

		fprintf(out_fp, "(");

		n2 = AS_COAL_NODE(nd)->out[0]->bot;
		while(n2->type == NODE_MIGR)
			n2 = AS_MIGR_NODE(n2)->out->bot;
		print_tree(out_fp, n2);
		fprintf(out_fp, ":%.10f", nd->t - n2->t);

		/* For debugging 
		n1 = nd;
		n2 = AS_COAL_NODE(nd)->out[0]->bot;
		fprintf(out_fp, ":");
		while(n2->type == NODE_MIGR){
			fprintf(out_fp, "%.10f;", n1->t - n2->t);
			n1 = n2;
			n2 = AS_MIGR_NODE(n2)->out->bot;
		}
		fprintf(out_fp, "%.10f", n1->t - n2->t);*/

		fprintf(out_fp, ",");

		n2 = AS_COAL_NODE(nd)->out[1]->bot;
		while(n2->type == NODE_MIGR)
			n2 = AS_MIGR_NODE(n2)->out->bot;
		print_tree(out_fp, n2);
		fprintf(out_fp, ":%.10f", nd->t - n2->t);

		/* For debugging
		n1 = nd;
		n2 = AS_COAL_NODE(nd)->out[1]->bot;
		fprintf(out_fp, ":");
		while(n2->type == NODE_MIGR){
			fprintf(out_fp, "%.10f;", n1->t - n2->t);
			n1 = n2;
			n2 = AS_MIGR_NODE(n2)->out->bot;
		}
		fprintf(out_fp, "%.10f", n1->t - n2->t);*/

#ifdef DEBUG
		fprintf(out_fp, ")%x:%.6f", nd, nd->t);
#else
		fprintf(out_fp, ")");
//		fprintf(out_fp, ")_%d", nd->in->id);
//		fprintf(out_fp, "):%.6f", nd->t);
#endif
	}else if(nd->type == NODE_DUMMY){
		struct node *n2;

#ifdef DEBUG
		fprintf(out_fp, "(");
#endif
		n2 = AS_DUMMY_NODE(nd)->out->bot;
		while(n2->type == NODE_MIGR)
			n2 = AS_MIGR_NODE(n2)->out->bot;
		print_tree(out_fp, n2);

#ifdef DEBUG
		fprintf(out_fp, ":%.10f", nd->t - n2->t);
		fprintf(out_fp, ")%x:%.6f", nd, nd->t);
#else
		fprintf(out_fp, ")");
#endif
	}
}

int cnt_rec;
/* Main algorithm of the coalescent simulator. */
int simulate(struct genealogy *G, struct profile *prof)
{
	struct config *cfg;
	struct reference *ref;
	struct list_head *l;
	struct frag *fgset;
	int f, pop, npop_all, ilast;
	int nfrag, reflen;
	struct list *F, R, Rold;
	struct timespec begin, end;
	double like, rho;
	double lb, ub;

	clock_gettime(CLOCK_MONOTONIC, &begin);

//	cnt_rec = 0;
	nfrag = prof->nfrag;
	fgset = prof->fgset;

//	ref = load_reference(prof->reffile);
/*	if(ref == NULL){
		fprintf(stderr, "Error opening reference file.");
		return -1;
	}*/
	ref = prof->ref;
	reflen = prof->ref->chrlen[prof->chrnum];
	reload_reference(ref, prof->chrnum);

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering %s\n", __func__);

	/* Print initial configuration. */
	fprintf(stderr, "Initial migration matrix:[\n");
	for(pop = 0; pop < cfg->npop; pop++){
		int i;
		for(i = 0; i < cfg->npop; i++)
			fprintf(stderr, "%.6f,", cfg->mmig[pop][i]);
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "]\n");

	/* Print growth rate. */
	fprintf(stderr, "Initial growth:[");
	for(pop = 0; pop < cfg->npop; pop++)
		fprintf(stderr, "%.6f,", cfg->grate[pop]);
	fprintf(stderr, "]\n");

	/* Print subpopulation size. */
	fprintf(stderr, "Initial subpopulation size:[");
	for(pop = 0; pop < cfg->npop; pop++)
		fprintf(stderr, "%.6f,", cfg->size[pop]);
	fprintf(stderr, "]\n");

	dump_events(G);
#endif
//	npop_all = cfg->npop + cfg->nsplt;
	npop_all = cfg->npop_all;

	seed();
	F = malloc(sizeof(struct list) * npop_all);
//	rho = cfg->rho * reflen;
	rho = cfg->rho;
	lb = ub = 0;
	ilast = 0;
	like = 0;
	f = 0;
	G->ev_dxvr = NULL;

	list_init(&R);
	list_init(&Rold);
	G->nsam = 0;
//	Rrear = &Rold;
	do{
		struct list_head *fgl, *evl;
	
		struct frag *fg;

		struct sam_node *nd;
		int i, j;
		double sublike;
		double x;
//		int x;

//		build_trunk_e(G, lb);
#ifdef DEBUG
		fprintf(stderr, "Tree after build_trunk:");
		if(G->root)
			print_tree(stderr, G->root);
		fprintf(stderr, "\n");
#endif
		/* Load next fragment sets. */
		for(i = 0; i < npop_all; i++)
			list_init(&F[i]);

		if(lb >= ub){
			lb = (double)fgset[f].start / reflen;
			ub = (double)fgset[f].end / reflen;
		}

//		for(i = 0; i < MAXFRAG && f < nfrag && fgset[f].start < ub; i++, f++){
		for(i = 0; i < cfg->maxfrag && f < nfrag; i++, f++){
			l = mem_cache_alloc(cfg->frag_cache);
			*((struct frag **)GET_OBJ(l)) = fg = &fgset[f];
			list_append(&R, GET_OBJ(l));
//			list_add(&R, GET_OBJ(l));

			if((double)fg->end / reflen > ub)
				ub = (double)fg->end / reflen;
		}

		if(f < nfrag){
			ub = (double)fgset[f].start / reflen;

		}else{
			ub = 1;
		}
#ifdef DEBUG
		l = R.front;
		fprintf(stderr, "%d: New reads: R", __LINE__);
		while(l){
			fg =  *((struct frag **)GET_OBJ(l));
			fprintf(stderr, "->(next=%x, prev=%x, id=%d, start=%d, end=%d)", l->next, l->prev, fg->id, fg->start, fg->end);
			l = l->next;
		}
		fprintf(stderr, "\n");
		fprintf(stderr, "%d: lb=%d, ub=%d\n", __LINE__, lb, ub);
#endif
		create_floating(G, &R, F);

		/* Add sample nodes to each subpopulation */
		for(i = 0; i < cfg->npop; i++){
			l = F[i].front;
			while(l){
				struct sam_node *nd;
				struct edge *e;

				e = (struct edge *)GET_OBJ(l);
				nd = (struct sam_node *)e->bot;
#ifdef DEBUG
				fprintf(stderr, "Sample node %x, frag id=%d, nread=%d, start=%d, end=%d\n", nd, nd->fg->id, nd->fg->nread, nd->fg->start, nd->fg->end);
				fprintf(stderr, "Adding sample node %x to population %d\n", nd, i);
#endif
				list_append(&G->n_list, e->bot);
				l = l->next;
			}
		}

		/* Remove reads in temporary list to main list. */
		list_concat(&Rold, &R);
		list_init(&R);
#ifdef DEBUG
		l = Rold.front;
		fprintf(stderr, "%d: Rold", __LINE__);
		while(l){
			fg = *((struct frag **)GET_OBJ(l));
			fprintf(stderr, "->(%d, start=%d, end=%d)", fg->id, fg->start, fg->end);
			l = l->next;
		}
		fprintf(stderr, "\n");
		fprintf(stderr, "G->nsam=%d\n", G->nsam);

		l = G->n_list.front;
		fprintf(stderr, "%d: Sample list", __LINE__);
		while(l){
			struct sam_node *sn = (struct sam_node *)GET_OBJ(l);
			fprintf(stderr, "->%x[node=%x]", l, sn);
			l = l->next;
		}
		fprintf(stderr, "\n\n");
#endif

		reset_populations(G);
		for(pop = 0; pop < cfg->npop; pop++){
			G->pops[pop].nsam += F[pop].n;
			G->nsam += F[pop].n;
		}
		G->t = 0;
		G->evlcurr = G->evlist->front;

		sublike = merge_floating(G, F);

#ifdef DEBUG
		fprintf(stderr, "%d: G->root=%x, G->localMRCA=%x\n\n", __LINE__, G->root, G->localMRCA);
#endif
		like += sublike;
		if(isinf(sublike))
			break;
		build_trunk_e(G, lb * reflen);


#ifdef DEBUG
		fprintf(stderr, "%d: G->root=%x, G->root->t=%.6f, G->localMRCA=%x, G->localMRCA->t=%.6f\n", __LINE__, G->root, G->root->t, G->localMRCA, G->localMRCA->t);

		/* Print sample list. */
		l = G->n_list.front;
		fprintf(stderr, "%d: Sample list", __LINE__);
		while(l){
			struct sam_node *sn = (struct sam_node *)GET_OBJ(l);
			fprintf(stderr, "->%x[node=%x]", l, sn);
			l = l->next;
		}
		fprintf(stderr, "\n");
		fprintf(stderr, "G->nsam=%d\n", G->nsam);

		fprintf(stderr, "\n");
		print_tree(stderr, G->root);
		fprintf(stderr, "\n");

		/* Print event list. */
		dump_events(G);

		fprintf(stderr, "%d:", __LINE__);
		dump_edges(G);
#endif

		x = lb;
//		x = 0;
		do{
			double u, rrho, r, treesize;
			int inext, to;

			G->total = L(G);
			treesize = G->total + G->root->t - G->localMRCA->t;
			rrho = rho * treesize;
			if(rrho > 0){
				r = dexp(rrho);
//				r = -log(dunif01()) / rrho;
//				r = (int)(-log(dunif01()) / rrho);
//				r = MAX(r, 1);

			}else{
				r = (ub - x);	/* No recombination. */
			}
//			r = (double)1 / 100000;
//			r = (double)1 / 100;

#ifdef DEBUG
			fprintf(stderr, "%d: G->total=%.6f, lb=%.6f, ub=%.6f, x=%d, r=%d\n", __LINE__, G->total, lb, ub, x, r);
#endif
			x = MIN(x + r, ub);
			inext = x * reflen - ilast;

#ifdef DEBUG
			fprintf(stderr, "\nL=%.10f, getRate()=%.10f, curPos=%.10f, off=%.10f, inext=%d, ilast=%d\n", G->total, rrho, x, r, inext, ilast);
			fprintf(stderr, "%d: ", __LINE__);
			print_tree(stderr, G->root);
			fprintf(stderr, "\n");
#endif
			if(inext > 0){	// If next recombination doesn't occur on current nucleotide position, output local tree or sequence
//			if(r >= 1){	// If next recombination doesn't occur on current nucleotide position, output local tree or sequence
				to = x * reflen;
				if(cfg->print_tree){
					fprintf(cfg->treefp, "[%d]", to - ilast);
					print_tree(cfg->treefp, G->localMRCA);
					fprintf(cfg->treefp, ";\n");
				}

				if(cfg->gensam)
					generate_sequence(ref, G, ilast, to);
				ilast = to;
			}
#ifdef DEBUG
			fprintf(stderr, "%d:", __LINE__);
			print_tree(stderr, G->root);
			fprintf(stderr, "\n");
#endif
			if(x < ub){
//				like += log(rho) - rrho * r;
				u = dunif01() * treesize;
				if(u < G->total){
					sublike = recombination(G);

				}else{
					double t;

					t = u - G->total + G->localMRCA->t;

#ifdef DEBUG
					fprintf(stderr, "%d: Dummy recombination occur at time %.10f, position %.10f, localMRCA->t=%.10f, root->t=%.10f\n", __LINE__, t, x, G->localMRCA->t, G->root->t);
#endif

					sublike = log(rho);
					if(G->ev_dxvr){
						if(G->ev_dxvr->t > t){
							struct event *ev_dxvr;

							ev_dxvr = alloc_event(G->cfg, EVENT_DXVR, t);
							remove_event(G, G->ev_dxvr);

							/* Change on 2018/05/31: Find first event after time of new event. The old version crashes in the presence of migration. */
							evl = G->evlist->front;
							while(((struct event *)GET_OBJ(evl))->t < ev_dxvr->t)
								evl = evl->next;
							/* End of change. */
							list_insbefore(evl, ev_dxvr);
							G->ev_dxvr = ev_dxvr;
						}

					}else{
						G->ev_dxvr = alloc_event(G->cfg, EVENT_DXVR, t);
						evl = G->evlist->front;
						while(((struct event *)GET_OBJ(evl))->t < G->ev_dxvr->t)
							evl = evl->next;
						list_insbefore(evl, G->ev_dxvr);
					}
				}
//				cnt_rec++;
//				like += sublike;
			}

#ifdef DEBUG
			dump_events(G);

			fprintf(stderr, "%d: edge list:", __LINE__);
			dump_edges(G);
			fprintf(stderr, "\n");

#endif
		}while(x < ub);
		lb = ub;

#ifdef DEBUG
		fprintf(stderr, "%d:", __LINE__);
		print_tree(stderr, G->root);
		fprintf(stderr, "\n");
#endif

		/* Output finished fragments. */
		fgl = Rold.front;
		while(fgl){
			struct list_head *tmp;
			tmp = fgl->next;
			fg = *((struct frag **)GET_OBJ(fgl));
			if((double)fg->end / reflen > ub)
				ub = (double)fg->end / reflen;
#ifdef DEBUG
			fprintf(stderr, "Fragment %d, nread=%d\n", fg->id, fg->nread);
#endif
			if(fg->end <= lb * reflen && fg->trunk == 0){
//			if(fg->end <= lb * reflen){

#ifdef DEBUG
				fprintf(stderr, "Finishing fragment %d\n", fg->id);
#endif
				__list_remove(&Rold, fgl);
//				G->nsam--;
				mem_cache_free(cfg->frag_cache, (char *)fgl);
			}
			fgl = tmp;
		}

#ifdef DEBUG
		l = Rold.front;
		fprintf(stderr, "%d: Remaining reads: Rold", __LINE__);
		while(l){
			fg =  *((struct frag **)GET_OBJ(l));
			fprintf(stderr, "->(%d, start=%d, end=%d)", fg->id, fg->start, fg->end);
			l = l->next;
		}
		fprintf(stderr, "\n");
#endif
	}while(lb < 1);
//fprintf(stderr, "\n");
		
	{
	struct list_head *fgl;
	struct frag *fg;
	int j;

	/* Clear read list. */
	fgl = Rold.front;
	while(fgl){
		struct list_head *tmp;
		tmp = fgl->next;
		fg = *((struct frag **)GET_OBJ(fgl));
		for(j = 0; j < fg->nread; j++){
			free(fg->rd[j].seq);
			fg->rd[j].seq = NULL;
		}
		__list_remove(&Rold, fgl);
		mem_cache_free(cfg->frag_cache, (char *)fgl);

		fgl = tmp;
	}
	}

	free(F);
//	unload_reference(ref);

	clock_gettime(CLOCK_MONOTONIC, &end);

#ifdef DEBUG
	fprintf(stderr, "Finishing %s\n\n", __func__);
#endif

//	fprintf(stderr, "cnt_rec=%d\n", cnt_rec);

//	fprintf(cfg->treefp, "%d\t%d\t%d\t%d\n", begin.tv_sec, begin.tv_nsec, end.tv_sec, end.tv_nsec);

//	if(ub < reflen){
//		return -Inf;

//	}else{
		return like;
//	}
}

/*SEXP tree_simulator(SEXP outfile, SEXP nfgp, SEXP profilep, SEXP rhop, SEXP nrepp)
{
	char *file;
	int i;

	file = (char *)CHAR(STRING_ELT(outfile, 0));
	for(i = 0; i < nrep; i++){
	}

	return R_NilValue;
}*/


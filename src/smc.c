/* This file includes codes generating genealogies over reference genome.
 * Genealogy are simulated under Sequentially Markov Coalescent model proposed by McVean and Cardin (2005) */

#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

#include "rand.h"
#include "util.h"
#include "smc.h"
#include "mutation.h"
#include "bit.h"
#include "evindex.h"
#include "tsindex.h"

#define MAXNSEC 1000000000

unsigned long long t_abs_merge = 0;
unsigned long long t_abs_xover = 0;
unsigned long long t_coal = 0;

unsigned long long n_abs_merge = 0;
unsigned long long n_abs_xover = 0;
unsigned long long n_coal = 0;

unsigned long long t_abs_time = 0;
unsigned long long t_coal_time = 0;

unsigned long long n_abs_time_merge = 0;
unsigned long long n_coal_time = 0;

unsigned long long n_abs_time_xover = 0;

unsigned long long ndiscard_merge = 0;
unsigned long long ndiscard_xover = 0;

unsigned long long n_clear_tree = 0;
unsigned long long t_clear_tree = 0;

unsigned long long n_build_trunk = 0;
unsigned long long t_build_trunk = 0;

unsigned long long t_trunk_coal = 0;
unsigned long long n_trunk_coal = 0;

double ulast;	// Last uniform random variable generated by abs_time

static inline void free_node(struct genealogy *G, struct node *nd)
{
#ifdef DEBUG
	fprintf(stderr, "Entering function %s, nd=%x(%.6f)\n", __func__, nd, nd->t);
#endif
	cache_free(G->node_cache[node_flag_gettype(nd)], nd);
//	free(nd);
}

static inline struct node *alloc_node(struct genealogy *G, int type, int pop, double t)
{
	struct node *nd;
	int npop_all;

	npop_all = G->cfg->npop + G->cfg->nsplt;
	nd = cache_alloc(G->node_cache[type]);
//	nd = malloc(nodesize[type] + sizeof(int) * 2 * npop_all);

	*((unsigned char *)&nd->set_id + sizeof(int)) = type;
	nd->pop = pop;
	nd->t = t;
	nd->xtid = nd->idx = 0;

#ifdef DEBUG
	fprintf(stderr, "%s:%d:Allocated node %x at time %.6f with type %d in subpopulation %d\n\n", __func__, __LINE__, nd, nd->t, nd->type, nd->pop);
#endif
	return nd;
}

struct node *copy_node(struct genealogy *G, struct node *old)
{
	struct node *new;
	int npop_all;

	npop_all = G->cfg->npop + G->cfg->nsplt;
	new = cache_alloc(G->node_cache[node_flag_gettype(old)]);
//	new = malloc(nodesize[old->type] + sizeof(int) * 2 * npop_all);
	new->t = old->t;
	new->pop = old->pop;
	new->type = old->type;

#ifdef DEBUG
	fprintf(stderr, "%s:%d:Allocated node %x at time %.6f with type %d in subpopulation %d\n\n", __func__, __LINE__, new, new->t, new->type, new->pop);
#endif
	return new;
}

static inline void __add_edge__(struct genealogy *G, int pop, struct node *e)
{
	int idx;
	idx = G->pops[pop].nedges++;
	G->pops[pop].eptrs[idx] = e;
	e->idx = idx;
}

/* Add an edge to a population. */
static inline void add_edge_r(struct genealogy *G, int pop, struct node *e)
{
	tsindex_add(&G->tr_xover, e);
	__add_edge__(G, pop, e);
}

/* Add an edge to a population. */
static inline void add_edge_m(struct genealogy *G, int pop, struct node *e)
{
	tsindex_add_r(&G->tr_xover, e);
	__add_edge__(G, pop, e);
}

static inline void __remove_edge__(struct genealogy *G, int pop, struct node *e)
{
	int idx;
	idx = e->idx;
	G->pops[pop].eptrs[idx] = G->pops[pop].eptrs[--(G->pops[pop].nedges)];
	G->pops[pop].eptrs[idx]->idx = idx;
}

static inline void remove_edge_r(struct genealogy *G, int pop, struct node *e)
{
	__remove_edge__(G, pop, e);
	tsindex_clear(&G->tr_xover, e);
	free_node(G, e);
}

static inline void remove_edge_m(struct genealogy *G, int pop, struct node *e)
{
	__remove_edge__(G, pop, e);
	tsindex_clear_r(&G->tr_xover, e);
	free_node(G, e);
}

void insert_event_rb_join(struct genealogy *G, struct join_event *jev)
{
	struct rb_traverser tr;

	rb_t_find(&tr, G->evidx.idx->tree, (void *)jev);
	dn_clear(G->cfg->npop_all, G->evidx.dn);
	G->evidx.dn[jev->popi] = 1;
	G->evidx.dn[jev->popj] = -1;

	dn_add(G->cfg->npop_all, GET_SUMDN(jev), G->evidx.dn);
	evindex_propagate_add(tr.rb_height, tr.rb_stack, G->cfg->npop_all, G->evidx.dn);

	insert_event_join_increase(G, jev);
}

void insert_event_rb_splt(struct genealogy *G, struct splt_event *sev)
{
	struct rb_traverser tr;

	rb_t_find(&tr, G->evidx.idx->tree, (void *)sev);
	dn_clear(G->cfg->npop_all, G->evidx.dn);
	G->evidx.dn[sev->newpop] = 1;
	G->evidx.dn[sev->pop] = -1;

	dn_add(G->cfg->npop_all, GET_SUMDN(sev), G->evidx.dn);
	evindex_propagate_add(tr.rb_height, tr.rb_stack, G->cfg->npop_all, G->evidx.dn);

	insert_event_splt_increase(G, sev);
}

void remove_event_rb_join(struct genealogy *G, struct join_event *jev)
{
	struct rb_traverser tr;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s, event=%x, type=%d, t=%.6f\n", __func__, jev, jev->type, jev->t);
#endif

	rb_t_find(&tr, G->evidx.idx->tree, (void *)jev);
	dn_clear(G->cfg->npop_all, G->evidx.dn);
	G->evidx.dn[jev->popi] = 1;
	G->evidx.dn[jev->popj] = -1;

	// Update tree values
	dn_sub(G->cfg->npop_all, GET_SUMDN(jev), G->evidx.dn);
	evindex_propagate_sub(tr.rb_height, tr.rb_stack, G->cfg->npop_all, G->evidx.dn);

	remove_event_join_decrease(G, jev);
}

void remove_event_rb_splt(struct genealogy *G, struct splt_event *sev)
{
	struct rb_traverser tr;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s, event=%x, type=%d, t=%.6f\n", __func__, sev, sev->type, sev->t);
#endif
	rb_t_find(&tr, G->evidx.idx->tree, (void *)sev);
	dn_clear(G->cfg->npop_all, G->evidx.dn);
	G->evidx.dn[sev->newpop] = 1;
	G->evidx.dn[sev->pop] = -1;

	// Update tree values
	dn_sub(G->cfg->npop_all, GET_SUMDN(sev), G->evidx.dn);
	evindex_propagate_sub(tr.rb_height, tr.rb_stack, G->cfg->npop_all, G->evidx.dn);

	remove_event_splt_decrease(G, sev);
}

void dump_events(struct genealogy *G)
{
	struct list_head *l;
	struct event *ev;

	l = G->evidx.idx->ls.front;
	ev = (struct event *)GET_OBJ(l);
	fprintf(stderr, "nevents=%d, Event list: G->evlist", G->evidx.idx->n);
	while(l){
		fprintf(stderr, "->");
		print_event(G->cfg, ev);
		ev = evindex_next(&l);
	}
	fprintf(stderr, "\n");
	print_event_tree(&G->evidx, "");
}

void
print_tree_structure (struct rb_node *node, int level)
{
  int i;

  /* You can set the maximum level as high as you like.
     Most of the time, you'll want to debug code using small trees,
     so that a large |level| indicates a ``loop'', which is a bug. */
  if (node == NULL)
    {
      fprintf (stderr, "<nil>");
      return;
    }

//  fprintf (stderr, "%d(", ((struct edge *)node->rb_data)->eid);
  fprintf (stderr, "%(", ((struct edge *)node->rb_data));

  for (i = 0; i <= 1; i++)
    {
      if (node->rb_link[i])
        {
            print_tree_structure (node->rb_link[i], level + 1);
        }
      else
        fprintf (stderr, "NULL");

      if (i == 0)
        fputs (", ", stderr);
    }

  fprintf(stderr, ")");
}

/* Prints the entire structure of |tree| with the given |title|. */
void
print_whole_tree (const struct rb_table *tree, const char *title)
{
  fprintf (stderr, "%s: ", title);
  print_tree_structure (tree->rb_root, 0);
  fprintf(stderr, "\n");
}

void dump_edges(struct genealogy *G)
{
	struct config *cfg;
	struct list_head *l;
	struct sam_node *sn;
	struct node *n;
	struct node *e;
	int i, j;
	char title[20];

	fprintf(stderr, "Entering %s\n", __func__);

	cfg = G->cfg;
	tsindex_dump(&G->tr_xover);
	fprintf(stderr, "Dangling edges:");
	e = G->localMRCA;
	while(e && e->in){
//		fprintf(stderr, "%x(%.6f, %.6f, %d), ", e, e->t, e->in->t);
		fprintf(stderr, "%x(%.6f, %.6f, itop=%d), ", e, e->t, e->in->t, e->itop);
		e = e->in;
	}
	fprintf(stderr, "\n\n");

	for(i = 0; i < cfg->npop_all; i++){
		fprintf(stderr, "Population %d:", i);

		fprintf(stderr, "All edges:[");
		for(j = 0; j < G->pops[i].nedges; j++){
			e = G->pops[i].eptrs[j];
			if(e)
//				fprintf(stderr, "%x(bot=%.10f, top=%.10f, eid=%d, xtid=%d),", e, e->t, e->in->t, e->eid, e->xtid);
				fprintf(stderr, "%x(j=%d, bot=%.10f, top=%.10f, xtid=%d, idx=%d, itop=%d),", e, j, e->t, e->in->t, e->xtid, e->idx, e->itop);

			else
				fprintf(stderr, "(NULL),");
		}
		fprintf(stderr, "]\n");
	}

	fprintf(stderr, "Leaving %s\n", __func__);
}

static inline struct node *insert_xover_node(struct genealogy *G, struct node *e, double t)
{
	struct node *nxover;

	nxover = copy_node(G, e);

	return nxover;
}

static inline void remove_xover_node(struct genealogy *G, struct node *nxover, struct node *ebelow)
{
	nxover->in->out[nxover->itop] = ebelow;
	ebelow->in = nxover->in;
	ebelow->itop = nxover->itop;
	ebelow->idx = nxover->idx;
	ebelow->xtid = nxover->xtid;
	G->pops[ebelow->pop].eptrs[ebelow->idx] = ebelow;
	G->tr_xover.edges[ebelow->xtid] = ebelow;
}

static inline void insert_coal_node(struct node *e, struct node *nd)
{
	e->in->out[e->itop] = nd;
	nd->in = e->in;
	nd->itop = e->itop;
}

static inline void __remove_coal_node(struct coal_node *nd, struct node *ebelow)
{
	nd->in->out[nd->itop] = ebelow;
	ebelow->in = nd->in;
	ebelow->itop = nd->itop;
}

static inline void remove_coal_node(struct genealogy *G, struct coal_node *nd, int iout)
{
	struct node *e;

	e = nd->out[1 - iout];
	remove_event_rb(G, (struct event *)GET_COAL_EVENT(nd));

	/* Extend edges above the coalescent node to be removed. */
	tsindex_update(&G->tr_xover, (struct node *)e, nd->in->t - nd->t);
	__remove_coal_node(nd, e);
	remove_edge_r(G, nd->pop, (struct node *)nd);
}

/* Erase dangling lineage until a coalescent node is reached. */
void erase_dangling2(struct genealogy *G, struct node *e)
{
	struct config *cfg;
	struct node *ntop, *nd, *ebelow;
	int pop, itop;
	struct migr_node *nm;

#ifdef DEBUG
	fprintf(stderr, "Entering %s\n", __func__);
	dump_edges(G);
#endif

	/* Remove dangling edges. */
	itop = edge_flag_getitop(e);
	ntop = e->in;
	__remove_edge__(G, e->pop, e);
	tsindex_clear(&G->tr_xover, e);
	while(!iscoalnode(ntop)){
		if(ntop->type == NODE_JOIN){
			join_set_remove(&AS_JOIN_NODE(ntop)->ev->ndls, ntop);
			remove_event_rb_join(G, AS_JOIN_NODE(ntop)->ev);

		}else if(ntop->type == NODE_SPLT){
			splt_set_remove(&AS_SPLT_NODE(ntop)->ev->ndls, ntop);
			remove_event_rb_splt(G, AS_SPLT_NODE(ntop)->ev);

		}else{
			remove_event_rb(G, (struct event *)GET_MIGR_EVENT(ntop));
		}

		e = ntop;
		itop = edge_flag_getitop(e);
		ntop = e->in;
		remove_edge_r(G, e->pop, e);
	}

	nd = ntop;
	ebelow = AS_COAL_NODE(ntop)->out[1 - itop];

	/* If the erased lineage is below localMRCA, then move down localMRCA. */
	if(ntop != G->localMRCA){
		// The edge above removed coalescent node is in local genealogy, so tsindex need to be updated. */
		remove_coal_node(G, (struct coal_node *)nd, itop);

	}else{
		/* Move downward along another branch to find new root. */
		ntop = ebelow;
		while(!iscoalnode(ntop) && !issamnode(ntop))
			ntop = ntop->out[0];
		G->localMRCA = ntop;

		// The edge above removed coalescent node is not in local genealogy, so we do not need to update tsindex. */
		remove_coal_node(G, (struct coal_node *)nd, itop);
	}

#ifdef DEBUG
	fprintf(stderr, "%s finisned\n", __func__);
#endif
}

struct node *trunk_search(struct genealogy *G, struct node_set *trunk, int pop, double t, int u)
{
	struct list_head *l, *evl;
	struct coal_event *cev;
	struct migr_event *mev;
	struct join_event *jev;
	struct splt_event *sev;
	struct event *ev;
	struct coal_node *cnd;
	struct migr_node *mnd;
	struct node *e;
	int i, c;

	e = G->root->out[0];
	if(e->t < t)
		return e;

	for(i = 0; i < G->cfg->npop_all; i++)
		node_set_clear(&G->trunk[i]);
	node_set_add(&G->trunk[e->pop], e);

	if(iscoalnode(e))
		ev = (struct event *)GET_COAL_EVENT(e);
	else if(ismigrnode(e))
		ev = (struct event *)GET_MIGR_EVENT(e);
	else if(isjoinnode(e))
		ev = (struct event *)AS_JOIN_NODE(e)->ev;
	else if(isspltnode(e))
		ev = (struct event *)AS_SPLT_NODE(e)->ev;

	evl = GET_LIST(ev);
	c = 0;
	while(ev->t > t){
		if(ev->type == EVENT_COAL){
			cev = (struct coal_event *)ev;
			cnd = GET_COAL_NODE(cev);
			__node_set_remove(&trunk[cnd->pop], cnd->set_id);

			if(cnd->pop == pop && cnd->out[0]->t < t && cnd->t > t){
				if(c < u) c++;
				else return cnd->out[0];
			}
			node_set_add(&trunk[cnd->pop], cnd->out[0]);

			if(cnd->pop == pop && cnd->out[1]->t < t && cnd->t > t){
				if(c < u) c++;
				else return cnd->out[1];
			}
			node_set_add(&trunk[cnd->pop], cnd->out[1]);

		}else if(ev->type == EVENT_MIGR){
			mev = (struct migr_event *)ev;
			mnd = GET_MIGR_NODE(mev);
			__node_set_remove(&trunk[mnd->pop], mnd->set_id);

			if(mnd->out->pop == pop && mnd->out->t < t && mnd->t > t){
				if(c < u) c++;
				else return mnd->out;
			}
			node_set_add(&trunk[mnd->out->pop], mnd->out);

		}else if(ev->type == EVENT_JOIN){
			jev = (struct join_event *)ev;
			for(i = 0; i < jev->ndls.n; i++){
				mnd = (struct migr_node *)node_set_get(&jev->ndls, i);
				__node_set_remove(&trunk[mnd->pop], mnd->set_id);

				if(mnd->out->pop == pop && mnd->out->t < t && mnd->t > t){
					if(c < u) c++;
					else return mnd->out;
				}
				node_set_add(&trunk[mnd->out->pop], mnd->out);
			}

		}else if(ev->type == EVENT_SPLT){
			sev = (struct splt_event *)ev;
			for(i = 0; i < sev->ndls.n; i++){
				mnd = (struct migr_node *)node_set_get(&sev->ndls, i);
				__node_set_remove(&G->trunk[mnd->pop], mnd->set_id);

				if(mnd->out->pop == pop && mnd->out->t < t && mnd->t > t){
					if(c < u) c++;
					else return mnd->out;
				}
				node_set_add(&trunk[mnd->out->pop], mnd->out);
			}
		}
		evl = (struct list_head *)evl->prev;
		ev = (struct event *)GET_OBJ(evl);
	}

	return NULL;
}

/* MaCS-like procedure for choosing coalescing edge. */
//struct edge *choose_tedge(struct genealogy *G, struct population *pop, double t)
struct node *choose_tedge(struct genealogy *G, int pop, double t)
{
	struct node *e, **eptrs;
	int n, nall, u;

	n = G->pops[pop].n;
	nall = G->pops[pop].nedges;
	eptrs = G->pops[pop].eptrs;

#ifdef DEBUG
	fprintf(stderr, "%s: %d: pop->n=%d, t=%.6f\n", __func__, __LINE__, n, t);
	dump_edges(G);
#endif
	if(2 * nall < (2 * n - 3) * n){
		do{
			u = dunif(nall);
			e = eptrs[u];
		}while(!(e->t < t && e->in->t > t));
		return e;

	}else{	// Choose edge using red-black index
		u = dunif(n);
		return trunk_search(G, G->trunk, pop, t, u);
	}
}

/* Absorb floating lineage n2 into e1. */
struct coal_node *__absorption(struct genealogy *G, struct node *e1, struct node *n2, int pop, double t)
{
	struct coal_node *nd;
	struct coal_event *ev;

	nd = (struct coal_node *)alloc_node(G, NODE_COAL, pop, t);
	ev = GET_COAL_EVENT(nd);
	init_event(G->cfg, (struct event *)ev, EVENT_COAL, t);

	/* Set up another branch below the coalescent node */
	insert_coal_node(e1, (struct node *)nd);

	nd->out[0] = e1;
	nd->out[1] = n2;

	e1->in = n2->in = (struct node *)nd;
	edge_flag_setleft(e1);
	edge_flag_setright(n2);

	GET_DN(ev)[pop] = -1;
	ev->pop = pop;

	return nd;
}

/* This must be called from merge_floating. */
struct coal_node *absorption(struct genealogy *G, struct node_set *trunk, struct node *nf, int pop, double t)
{
	struct node *e;
	struct coal_node *nd;
	int u;

//	struct timespec beg, end;
//	int nsec;
//	n_abs_merge++;
//	clock_gettime(CLOCK_MONOTONIC, &beg);

	u = dunif(trunk[pop].n);
	e = node_set_get(&trunk[pop], u);
	if(isdeleted(e)){	// This absorption can be ignored
		insert_coal_node(e, nf);
		nf->idx = e->idx;
		nf->xtid = e->xtid;
		G->pops[pop].eptrs[nf->idx] = nf;
		G->tr_xover.edges[nf->xtid] = nf;
		G->tr_xover.weights[nf->xtid] = nf->in->t - nf->t;

		node_set_replace(&trunk[pop], e->set_id, nf);
		free_node(G, e);

//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_abs_merge += nsec;
		return NULL;

	}else{
		nd = __absorption(G, e, nf, pop, t);
		add_edge_m(G, pop, (struct node *)nd);
		add_edge_m(G, pop, nd->out[1]);

		G->tr_xover.weights[e->xtid] = e->in->t - e->t;
		node_set_replace(&trunk[pop], e->set_id, (struct node *)nd);

//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_abs_merge += nsec;
		return nd;
	}
}

/* This must be called from merge_floating. */
struct coal_node *__coalescent(struct genealogy *G, struct node *n1, struct node *n2, int pop, double t)
{
	struct edge *e_new, *e2;
	struct coal_node *nd;
	struct coal_event *ev;

	nd = (struct coal_node *)alloc_node(G, NODE_COAL, pop, t);
	ev = GET_COAL_EVENT(nd);
	init_event(G->cfg, (struct event *)ev, EVENT_COAL, t);

	nd->out[0] = n1;
	nd->out[1] = n2;
	n1->in = n2->in = (struct node *)nd;
	edge_flag_setleft(n1);
	edge_flag_setright(n2);

	GET_DN(ev)[pop] = -1;
	ev->pop = pop;

	return nd;
}

//struct event *coalescent( struct genealogy *G, struct node_set *F, int pop, double t)
struct coal_node *coalescent( struct genealogy *G, struct node_set *F, int pop, double t)
{
	struct node *n1, *n2;
	struct coal_node *nd;
	int c1, c2;

//	struct timespec beg, end;
//	int nsec;
// 	n_coal++;
//	clock_gettime(CLOCK_MONOTONIC, &beg);

	c1 = dunif(F[pop].n) ;
	while( ( c2 = dunif(F[pop].n) ) == c1 );

//	if(c1 > c2){
//		n1 = node_set_get(&F[pop], c2);
//		n2 = node_set_remove(&F[pop], c1);
//	}else{
		n1 = node_set_get(&F[pop], c1);
		n2 = node_set_remove(&F[pop], c2);
//	}

	nd = __coalescent(G, n1, n2, pop, t);
	node_set_replace(&F[pop], n1->set_id, (struct node *)nd);

//	clock_gettime(CLOCK_MONOTONIC, &end);
//	nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//	t_coal += nsec;

	return nd;
}

/* Migrate single floating lineage. */
struct join_node *do_join(struct genealogy *G, struct node *nf, int dpop, int spop, double t)
{
	struct join_node *nd;
	struct node *e2;

#ifdef DEBUG
	fprintf(stderr, "%s: %d: Moving node %x from population %d to %d\n", __func__, __LINE__, nf, dpop, spop);
#endif
	nd = (struct join_node *)alloc_node(G, NODE_JOIN, spop, t);

	// The edge above nd must be floating
	nd->out = nf;
	nf->in = (struct node *)nd;
	nf->itop = 0;

	return nd;
}

/* Migrate single floating lineage. */
struct splt_node *do_splt(struct genealogy *G, struct node *nf, int dpop, int spop, double t)
{
	struct splt_node *nd;
	struct node *e2;

#ifdef DEBUG
	fprintf(stderr, "%s: %d: Moving node %x from population %d to %d\n", __func__, __LINE__, nf, dpop, spop);
#endif
	nd = (struct splt_node *)alloc_node(G, NODE_SPLT, spop, t);

	// The edge above nd must be floating
	nd->out = nf;
	nf->in = (struct node *)nd;
	nf->itop = 0;

	return nd;
}

/* Migrate single floating lineage. */
int nmigr = 0;
struct migr_node *do_migrate(struct genealogy *G, struct node *nf, int dpop, int spop, double t)
{
	struct migr_node *nd;
	struct node *e2;

	nmigr++;
#ifdef DEBUG
	fprintf(stderr, "%s: %d: Moving node %x from population %d to %d\n", __func__, __LINE__, nf, dpop, spop);
#endif
	nd = (struct migr_node *)alloc_node(G, NODE_MIGR, spop, t);

	// The edge above nd must be floating
	nd->out = nf;
	nf->in = (struct node *)nd;
	nf->itop = 0;

	return nd;
}

struct migr_node *__migration(struct genealogy *G, struct node *nf, int dpop, double t)
{
	struct config *cfg;
	struct migr_event *ev;
	struct migr_node *nd;
	struct list_head *l;
	double u, sum;
	int spop;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	cfg = G->cfg;
	// Generate source population (in forward-time sense) at random
	u = dunif01() * G->pops[dpop].mrate[dpop];
	sum = 0;
	for(spop = 0; spop < cfg->npop + cfg->nsplt; spop++){
		if(spop != dpop && G->pops[spop].enabled){
			sum += G->pops[dpop].mrate[spop];
		}
		if(u < sum)
			break;
	}
#ifdef DEBUG
	fprintf(stderr, "%s: %d: Moving node %x from population %d to %d at time %.10f\n", __func__, __LINE__, nf, dpop, spop, t);
#endif
	nd = do_migrate(G, nf, dpop, spop, t);

	ev = GET_MIGR_EVENT(nd);
	init_event(G->cfg, (struct event *)ev, EVENT_MIGR, t);

	GET_DN(ev)[spop]++;
	GET_DN(ev)[dpop]--;
	ev->dpop = dpop;
	ev->spop = spop;

#ifdef DEBUG
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
	return nd;
}

static inline int isvisited(struct node *nd)
{
	return nd->visited & (NODE_FLAG_VISITED_LEFT | NODE_FLAG_VISITED_RIGHT);
}

static inline int visited_lr(struct node *nd)
{
	int lr;
	lr = nd->visited & (NODE_FLAG_VISITED_LEFT | NODE_FLAG_VISITED_RIGHT);
	return lr - 1;
}

static inline void visit(struct node *nd, char lr)
{
	nd->visited |= (lr + 1);
}

static inline void unvisit(struct node *nd)
{
	nd->visited &= ~(NODE_FLAG_VISITED_LEFT | NODE_FLAG_VISITED_RIGHT);
}

/* Clear nodes and edges of finished reads. */
void clear_tree(struct genealogy *G)
{
	struct config *cfg;
	struct list_head *nl, *next, *l;
	struct node_set *trunk;
	struct event *ev0;
	struct sam_node *snd;
	struct migr_node *nm;
	struct node *nd, **remove_list;
	struct node *e, *e2, *ebelow;
	int pop, itop, i, j, nca, nsam;

//	struct timespec beg, end;
//	int nsec;
//	n_clear_tree++;
//	clock_gettime(CLOCK_MONOTONIC, &beg);

	trunk = G->trunk;
	cfg = G->cfg;
	nsam = 0;
	for(i = 0; i < cfg->npop_all; i++){
		j = 0;
		while(j < trunk[i].n){
			e = node_set_get(&trunk[i], j);
			if(!isdeleted(e))
				__node_set_remove(&trunk[i], j);
			else
				j++;
		}
		nsam += trunk[i].n;
	}

	remove_list = malloc(sizeof(struct node *) * nsam);
	nca = 0;
	for(i = 0; i < cfg->npop_all; i++){
		j = 0;
		for(j = 0; j < trunk[i].n; j++){
			e = node_set_get(&trunk[i], j);
			pop = i;
			do{
				nd = e->in;
#ifdef DEBUG
				fprintf(stderr, "%s: %d: e=%x(%.6f), nd=%x(%.6f)\n", __func__, __LINE__, e, e->t, nd, nd->t);
#endif
				while(!iscoalnode(nd)){
#ifdef DEBUG
					fprintf(stderr, "%s: %d: ", __func__, __LINE__);
#endif
					__remove_edge__(G, e->pop, e);
					tsindex_clear_r(&G->tr_xover, e);
					if(!isvisited(e))
						free_node(G, e);

					if(nd->type == NODE_JOIN){
						join_set_remove(&AS_JOIN_NODE(nd)->ev->ndls, nd);
						remove_event_join_decrease(G, AS_JOIN_NODE(nd)->ev);

					}else if(nd->type == NODE_SPLT){
						splt_set_remove(&AS_SPLT_NODE(nd)->ev->ndls, nd);
						remove_event_splt_decrease(G, AS_SPLT_NODE(nd)->ev);

					}else{
						__remove_event_s(G, (struct event *)GET_MIGR_EVENT(nd));
					}
					e = nd;
#ifdef DEBUG
					fprintf(stderr, "%s: %d: ", __func__, __LINE__);
#endif
					nd = e->in;
				}

				if(!isvisited(nd))
					remove_list[nca++] = nd;
				itop = edge_flag_getitop(e);
				visit(nd, itop);
				__remove_edge__(G, e->pop, e);
				tsindex_clear_r(&G->tr_xover, e);
				if(!isvisited(e))
					free_node(G, e);
				e = nd;
			}while(visited_lr(nd) == (NODE_FLAG_VISITED_LEFT | NODE_FLAG_VISITED_RIGHT) - 1);	// Continue if both branch of a coalescent node is removed
		}
	}

	/* Remove coalescent nodes from remove_list. */
	for(i = 0; i < nca; i++){
		nd = remove_list[i];
		__remove_event_s(G, (struct event *)GET_COAL_EVENT(nd));
		if(visited_lr(nd) == (NODE_FLAG_VISITED_LEFT | NODE_FLAG_VISITED_RIGHT) - 1){	// Both edges are removed
			free_node(G, nd);

		}else{	// One edge is still in the local genealogy
			ebelow = AS_COAL_NODE(nd)->out[1 - visited_lr(nd)];
			__remove_coal_node((struct coal_node *)nd, ebelow);
			remove_edge_m(G, nd->pop, (struct node *)nd);
			G->tr_xover.weights[ebelow->xtid] = ebelow->in->t - ebelow->t;
		}
	}

	/* Find new MRCA */
	nd = G->root;
	while(!iscoalnode(nd))
		nd = AS_MIGR_NODE(nd)->out;
	G->localMRCA = nd;

	free(remove_list);

//	clock_gettime(CLOCK_MONOTONIC, &end);
//	nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//	t_clear_tree += nsec;
}

/* Modify population configuration according to an event. */
void update_demography(struct genealogy *G, struct event *ev)
{
	int pop, all_pops, i, j;

	all_pops = G->cfg->npop + G->cfg->nsplt;
#ifdef DEBUG
	fprintf(stderr, "%s: (%d, %.6f", __func__, ev->type, ev->t);
#endif

	if(ev->type == EVENT_GROW){
		int epop;

		epop = ((struct grow_event *)ev)->pop;
		G->pops[epop].size *= exp(-G->pops[epop].grate * (ev->t - G->pops[epop].tlast));
		G->pops[epop].tlast = ev->t;
		G->pops[epop].grate = ((struct grow_event *)ev)->alpha;
		if(G->pops[epop].grate != 0)
			G->pops[epop].growth = 1;

	}else if(ev->type == EVENT_SIZE){	/* Change size of a subpopulation */
		G->pops[((struct size_event *)ev)->pop].size = ((struct size_event *)ev)->size;

	}else if(ev->type == EVENT_RMIG){	/* Modify migration rate from subpopulation i to subpopulation j. */
		struct rmig_event *rev = (struct rmig_event *)ev;
		G->pops[rev->popi].mrate[rev->popj] = rev->rmig;

	}else if(ev->type == EVENT_GMIG){	/* Change migration rate. */
		double mig_rate;
		int npop;

		mig_rate = ((struct gmig_event *)ev)->rmig;

		npop = 0;
		for(i = 0; i < all_pops; i++)
			npop += (G->pops[i].enabled != 0);

		for(i = 0; i < all_pops; i++){
			if(G->pops[i].enabled){
				for(j = 0; j < all_pops; j++){
					if(G->pops[j].enabled){
						if(i == j){
							G->pops[i].mrate[j] = mig_rate;

						}else{
							G->pops[i].mrate[j] = mig_rate / (npop - 1);
						}
					}
				}
			}
		}

	}else if(ev->type == EVENT_GSIZ){	/* Change size of all subpopulations. */
		for(i = 0; i < all_pops; i++)
			if(G->pops[i].enabled)
				G->pops[i].size = ((struct gsiz_event *)ev)->size;

	}else if(ev->type == EVENT_GGRO){	/* Change growth rate of all subpopulations. */
		for(i = 0; i < all_pops; i++){
			if(G->pops[i].enabled){
				G->pops[i].size *= exp(-G->pops[i].grate * (ev->t - G->pops[i].tlast));
				G->pops[i].tlast = ev->t;
				G->pops[i].grate = ((struct ggro_event *)ev)->alpha;
				if(((struct ggro_event *)ev)->alpha != 0)
					G->pops[i].growth = 1;
			}
		}

	}else if(ev->type == EVENT_JOIN){	/* Population join */
		struct join_event *jev;

		jev = (struct join_event *)ev;
		/* Clear migration matrix of merged population. */
		G->pops[jev->popj].enabled = 0;
		for(i = 0; i < all_pops; i++)
			if(i != jev->popj)
				G->pops[i].mrate[jev->popj] = 0;

		for(i = 0; i < all_pops; i++){
			G->pops[i].mrate[i] = 0;
			for(j = 0; j < all_pops; j++)
				if(i != j)
					G->pops[i].mrate[i] += G->pops[i].mrate[j];
		}

		G->pops[jev->popi].n += GET_DN(jev)[jev->popi];
		G->pops[jev->popj].n += GET_DN(jev)[jev->popj];

	}else if(ev->type == EVENT_SPLT){	/* Population split */
		struct splt_event *sev;
		int pop, newpop;

		sev = (struct splt_event *)ev;
		pop = sev->pop;
		newpop = sev->newpop;
		G->pops[sev->newpop].enabled = 1;
		G->pops[sev->newpop].size = G->pops[sev->pop].size;
		G->pops[sev->newpop].grate = 0;
		G->pops[sev->newpop].growth = 0;

		G->pops[sev->newpop].n += GET_DN(sev)[sev->newpop];
		G->pops[sev->pop].n += GET_DN(sev)[sev->pop];

	}else if(ev->type == EVENT_SAMP){
		for(i = 0; i < G->cfg->npop_all; i++)
			G->pops[0].n += GET_DN(ev)[i];
	}

#ifdef DEBUG
	fprintf(stderr, ")\n");
#endif
}

/* Calculate total branch length */
static inline double L(struct genealogy *G)
{
	double total;

	total = tsindex_size(&G->tr_xover);

	return total;
}

void reset_populations(struct genealogy *G)
{
	struct config *cfg;
	int pop, i;

	cfg = G->cfg;
	/* Reset populations existing at time 0. */
	for(pop = 0; pop < cfg->npop; pop++){
		G->pops[pop].n = G->pops[pop].nsam;
		G->pops[pop].enabled = 1;
		G->pops[pop].grate = cfg->grate[pop];
		G->pops[pop].growth = cfg->grate[pop] != 0;
		G->pops[pop].size = cfg->size[pop];
		for(i = 0; i < cfg->npop; i++)
			G->pops[pop].mrate[i] = cfg->mmig[pop][i];

		for(; i < cfg->npop + cfg->nsplt; i++)
			G->pops[pop].mrate[i] = 0;
	}

	/* Reset populations created by splt event. */
	for(;pop < cfg->npop + cfg->nsplt; pop++){
		G->pops[pop].n = 0;
		G->pops[pop].growth = 0;
		G->pops[pop].enabled = 0;
		G->pops[pop].grate = 0;
		G->pops[pop].size = 0;
		G->pops[pop].tlast = 0;
		memset(G->pops[pop].mrate, 0, sizeof(double) * (cfg->npop + cfg->nsplt));
	}

	evindex_s_rewind(&G->evidx);
}

/* Select a point uniformly on G. Note that selected point must be below root.
 * The event next to the new event time will be returned. */
double rnd_select_point(struct genealogy *G, struct node **eo)
{
	double g, t, running;
	struct node *e;

#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif

	/* Generate a point on the genealogy. */
	g = G->total * dunif01();

#ifdef DEBUG
	fprintf(stderr, "g=%.6f\n", g);
#endif
	/* Change on 2018/05/13: Search a a random point on current local genealogy by searching binary indexed tree. */
	*eo = e = tsindex_search(&G->tr_xover, g, &running);
	t = e->t + g - running;

	return t;
}

struct event *trace_event(struct genealogy *G, double t)
{
	struct event *ev;
	int i;

	reset_populations(G);

	for(i = 0; i < G->cfg->ndevents; i++){
		ev = G->cfg->devents[i];
		if(ev->t > t)
			break;
		else
			update_demography(G, ev);
	}

	ev = evindex_query(&G->evidx, t, G->evidx.dn);
	evindex_s_set(&G->evidx, ev);
	for(i = 0; i < G->evidx.npop_all; i++)
		G->pops[i].n = G->evidx.dn[i];

	return ev;
}

double abs_time(struct genealogy *G, int nF, int pop, double t)
{
	double size, alpha, tlast, r, u, dt;

//	struct timespec beg, end;
//	int nsec;
//	clock_gettime(CLOCK_MONOTONIC, &beg);

	size = G->pops[pop].size;
	if(!G->pops[pop].growth){
		dt = dexp((nF << 1) * G->pops[pop].n / size);
//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_abs_time += nsec;

		return dt;

	}else{
		tlast = G->pops[pop].tlast;
		alpha = G->pops[pop].grate;
		u = dunif01();
		r = 1 - alpha * size * exp(-alpha * (t - tlast)) * log(u) / ((nF << 1) * G->pops[pop].n);
		dt = log(r) / alpha;
//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_abs_time += nsec;

		return dt;
	}
}

// Time of next coalescent or absorption event
double ca_time(struct genealogy *G, int nF, int pop, double t)
{
	double size, alpha, tlast, r, u, dt;
	int npair;

//	struct timespec beg, end;
//	int nsec;
//	n_coal_time++;
//	clock_gettime(CLOCK_MONOTONIC, &beg);

	npair = nF * ((nF - 1) + (G->pops[pop].n << 1));
	size = G->pops[pop].size;

	if(!G->pops[pop].growth){
		dt = dexp(npair / size);

//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_coal_time += nsec;

		return dt;

	}else{
		alpha = G->pops[pop].grate;
		tlast = G->pops[pop].tlast;
		u = dunif01();
		r = 1 - alpha * size * exp(-alpha * (t - tlast)) * log(u) / npair;
		dt = log(r) / alpha;

//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_coal_time += nsec;

		return dt;
	}
}

double merge_floating(struct genealogy *G, struct node_set *trunk, struct node_set *F);

void erase_dummy_path_rb(struct genealogy *G, struct node *edum)
{
	struct node *nrm, *ndum;
	struct node *erm;
	int poprm;

	ndum = edum->in;
	/* Remove dangling edges above dummy recombination event from red-black tree. */
	G->ev_dxvr = NULL;
	erm = ndum;
	nrm = ndum;
	poprm = ndum->pop;
	while(erm->in){
		nrm = erm->in;
		if(erm->type == NODE_JOIN){
			join_set_remove(&AS_JOIN_NODE(erm)->ev->ndls, erm);
			remove_event_rb_join(G, AS_JOIN_NODE(erm)->ev);

		}else if(erm->type == NODE_SPLT){
			splt_set_remove(&AS_SPLT_NODE(erm)->ev->ndls, erm);
			remove_event_rb_splt(G, AS_SPLT_NODE(erm)->ev);

		}else{
			remove_event_rb(G, (struct event *)GET_MIGR_EVENT(erm));
		}
		remove_edge_r(G, erm->pop, erm);
		erm = nrm;
	}

	if(nrm->type == NODE_JOIN){
		join_set_remove(&AS_JOIN_NODE(nrm)->ev->ndls, nrm);
		remove_event_rb_join(G, AS_JOIN_NODE(nrm)->ev);

	}else if(nrm->type == NODE_SPLT){
		splt_set_remove(&AS_SPLT_NODE(nrm)->ev->ndls, nrm);
		remove_event_rb_splt(G, AS_SPLT_NODE(nrm)->ev);

	}else if(nrm->type == NODE_DUMMY){
		remove_event_rb(G, (struct event *)GET_DUMMY_EVENT(nrm));

	}else{
		remove_event_rb(G, (struct event *)GET_MIGR_EVENT(nrm));
	}

	free_node(G, nrm);
	G->pops[edum->pop].n = 0;
}

void erase_dummy_path_s(struct genealogy *G, struct node *edum)
{
	struct node *nrm, *ndum;
	struct node *erm;
	int poprm;

	ndum = edum->in;
	/* Remove dangling edges above dummy recombination event from red-black tree. */
	G->ev_dxvr = NULL;
	erm = ndum;
	nrm = ndum;
	poprm = ndum->pop;
	while(erm->in){
		nrm = erm->in;
		if(erm->type == NODE_JOIN){
			join_set_remove(&AS_JOIN_NODE(erm)->ev->ndls, erm);
			remove_event_join_decrease(G, AS_JOIN_NODE(erm)->ev);

		}else if(erm->type == NODE_SPLT){
			splt_set_remove(&AS_SPLT_NODE(erm)->ev->ndls, erm);
			remove_event_splt_decrease(G, AS_SPLT_NODE(erm)->ev);

		}else{
			remove_event_s(G, (struct event *)GET_MIGR_EVENT(erm));
		}
		remove_edge_m(G, erm->pop, erm);
		erm = nrm;
	}

	if(nrm->type == NODE_JOIN){
		join_set_remove(&AS_JOIN_NODE(nrm)->ev->ndls, nrm);
		remove_event_join_decrease(G, AS_JOIN_NODE(nrm)->ev);

	}else if(nrm->type == NODE_SPLT){
		splt_set_remove(&AS_SPLT_NODE(nrm)->ev->ndls, nrm);
		remove_event_splt_decrease(G, AS_SPLT_NODE(nrm)->ev);

	}else if(nrm->type == NODE_DUMMY){
		remove_event_s(G, (struct event *)GET_DUMMY_EVENT(nrm));

	}else if(nrm->type == NODE_MIGR){
		remove_event_s(G, (struct event *)GET_MIGR_EVENT(nrm));

	}else{
		remove_event_s(G, (struct event *)GET_COAL_EVENT(nrm));
	}

	free_node(G, nrm);
	G->pops[edum->pop].n = 0;
}

/* Remove dangling edges above dummy recombination event. */
void erase_dummy_path(struct genealogy *G, struct node *edum)
{
	if(rbindex_isseq(G->evidx.idx))
		erase_dummy_path_s(G, edum);
	else
		erase_dummy_path_rb(G, edum);
}

double merge_floating_r(struct genealogy *G, struct node_set *trunk, struct node_set *F)
{
	struct config *cfg;
	int pop, uvpop, zpop, sumnF, i, c, nfrom, npop_all;
	double t, uv, minuv, z, minz, rmig;
	double pabs, rate1, rate2, sum, x, inc, u;
	struct node *last, *nf, *nd, *edum, *ndum, *e;
	struct event *ev, *evnew;
	struct migr_node *nm;
	struct join_event *jev;
	struct splt_event *sev;
	struct list_head *f, *l, *next;

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	npop_all = cfg->npop + cfg->nsplt;
	t = G->t;
	sumnF = 0;
	for(pop = 0; pop < cfg->npop_all; pop++){
		sumnF += F[pop].n;
	}

	/* If trunk genealogy is not empty, loop until all floating lineages are absorbed.
	   Otherwise, loop until only one floating lineage remained. */
	while((G->root != NULL && sumnF > 0) || (G->root == NULL && sumnF > 1)){
		rmig = 0;
		minuv = minz = INFINITY;
		uvpop = zpop = 0;
		for(pop = 0; pop < npop_all; pop++){
			if(F[pop].n > 0){
//n_abs_time_merge++;
				uv = ca_time(G, F[pop].n, pop, t);
#ifdef DEBUG
				fprintf(stderr, "%d: ca_time=%.10f, nF[%d]=%d, G->pops[%d].n=%d\n", __LINE__, uv, pop, F[pop].n, pop, G->pops[pop].n);
#endif
				if(uv < minuv){
					minuv = uv;
					uvpop = pop;
				}
			}
		}

		if(npop_all > 1){
			rmig = 0;
			for(pop = 0; pop < cfg->npop + cfg->nsplt; pop++)
				rmig += G->pops[pop].mrate[pop] * F[pop].n;

			if(rmig > 0)
				minz = dexp(rmig);
		}

		ev = evindex_s_get(&G->evidx);
		if(isinf(minuv) && isinf(minz) && isinf(ev->t)){
			fprintf(stderr, "%d: Infinite time to next event\n", __LINE__);
			exit(-1);
		}
#ifdef DEBUG
		fprintf(stderr, "%d:", __LINE__);
		for(i = 0; i < cfg->npop + cfg->nsplt; i++)
			fprintf(stderr, ",G->pops[%d].n=%d", i, G->pops[i].n);
		fprintf(stderr, "\n");

		fprintf(stderr, "%d: Next event: ev=%x, type=%d, t=%6f\n", __LINE__, ev, ev->type, ev->t);
#endif

		if(t + minuv < ev->t || t + minz < ev->t){
			evnew = NULL;
			if(minuv < minz){	// Coalescent or Absorption
				// Calculate probability of absorption event
				t += minuv;
				sumnF--;
				dunif01();
				last = nd = (struct node *)coalescent(G, F, uvpop, t);
				add_edge_r(G, uvpop, nd->out[0]);
				add_edge_r(G, uvpop, nd->out[1]);
				evnew = (struct event *)GET_COAL_EVENT(nd);

			}else{	// Migration
				t += minz;
				x = rmig * dunif01();
				sum = 0;
				for(zpop = 0; zpop < npop_all; zpop++){
					inc = G->pops[zpop].mrate[zpop] * F[zpop].n;
					if(x < sum + inc)
						break;
					else
						sum += inc;
				}
				c = (int)((x - sum) / G->pops[zpop].mrate[zpop]);

finish_selection:
				// Find the lineage to be migrated
				nd = node_set_remove(&F[zpop], c);

				/* Perform migration */
#ifdef DEBUG
				fprintf(stderr, "%s: %d: ", __func__, __LINE__);
#endif
				nm = __migration(G, nd, zpop, t);
				add_edge_r(G, nd->pop, nd);

				last = (struct node *)nm;
				evnew = (struct event *)GET_MIGR_EVENT(nm);
				node_set_add(&F[((struct migr_event *)evnew)->spop], (struct node *)nm);
			}

			if(evnew)	// evnew is NULL when the absorption event is ignored because the absorption target will be removed later
				insert_event_rb(G, evnew);

		}else{
//ndiscard_merge++;
			t = ev->t;
			evindex_s_forward(&G->evidx);
			update_demography(G, ev);
			if(ev->type == EVENT_JOIN){
				struct join_node *nj;

				jev = (struct join_event *)ev;
				/* Move all new lineages in population j to population i. */
				for(i = 0; i < F[jev->popj].n; i++){
					nd = node_set_get(&F[jev->popj], i);
#ifdef DEBUG
					fprintf(stderr, "%s: %d: ", __func__, __LINE__);
#endif
					nj = (struct join_node *)do_join(G, nd, jev->popj, jev->popi, t);
					add_edge_r(G, nd->pop, nd);

					node_set_add(&F[jev->popi], (struct node *)nj);
					nj->ev = (struct join_event *)ev;
					join_set_add(&jev->ndls, (struct node *)nj);
					insert_event_rb_join(G, (struct join_event *)ev);
				}

				node_set_clear(&F[jev->popj]);

			}else if(ev->type == EVENT_SPLT){
				struct splt_node *ns;

				sev = (struct splt_event *)ev;
				/* Move new lineages in population old population to new population with probability sev->prop. */
				i = 0;
				while(i < F[sev->pop].n){
					u = dunif01();
					if(u >= sev->prop){
						nd = node_set_remove(&F[sev->pop], i);
						ns = (struct splt_node *)do_splt(G, nd, sev->pop, sev->newpop, t);
						add_edge_r(G, nd->pop, nd);

						node_set_add(&F[sev->newpop], (struct node *)ns);
						ns->ev = (struct splt_event *)ev;
						splt_set_add(&sev->ndls, (struct node *)ns);
						insert_event_rb_splt(G, (struct splt_event *)ev);

					}else{
						i++;
					}
				}
			}
		}
	}

	for(i = 0; i < npop_all; i++){
		if(F[i].n > 0){
			nd = node_set_remove(&F[i], 0);
			ndum = alloc_node(G, NODE_DUMMY, nd->pop, nd->t);
			init_event(G->cfg, (struct event *)GET_DUMMY_EVENT(ndum), EVENT_DUMY, ndum->t);
			ndum->in = NULL;
			AS_DUMMY_NODE(ndum)->out = nd;
			nd->in = ndum;
			e = nd;
			break;
		}
	}
	edge_flag_settype(e->in, NODE_DUMMY);
	e->in->t = e->t;
	e->in->pop = e->pop;
	e->in->in = NULL;
	add_edge_r(G, e->pop, e);
	G->troot = e->in->t;

	G->root = e->in;
	G->localMRCA = e;

	evnew = (struct event *)GET_DUMMY_EVENT(e->in);
	while((evindex_s_get(&G->evidx))->t < evnew->t)
		evindex_s_forward(&G->evidx);
	insert_event_rb(G, evnew);

#ifdef DEBUG
	fprintf(stderr, "%d: Leaving %s", __LINE__, __func__);
#endif
	return 0;
}

/* Generate recombination point and modify genealogy */
double recombination(struct genealogy *G, double x)
{
	struct config *cfg;
	struct list_head *l;
	int pop, coalesced, i, reflen;	// coalesced: flag indicating whether floating lineage is absorbed
	struct event *ev, *evnew;
	struct node *e, *e2, *nf, *nd, *last, *edum, *ndum, *nxover;	// e: edge where recombination event occur
	double t, at, mg, dmig, u;
	struct migr_node *nm;
	struct splt_event *sev;
	struct join_event *jev;
	int npop_all;

	if(tsindex_isrebuild(&G->tr_xover))
		tsindex_rebuild(&G->tr_xover);

	cfg = G->cfg;
	npop_all = cfg->npop_all;

	/* Choose recombination point at random. */
	t = rnd_select_point(G, &e);
	pop = e->pop;

	if(t > G->localMRCA->t){
		/* Deal with dummy recombination event. */
#ifdef DEBUG
		fprintf(stderr, "%s: %d: Dummy recombination occur at time %.10f, position %.10f, localMRCA->t=%.10f, root->t=%.10f\n", __func__, __LINE__, t, x, G->localMRCA->t, G->root->t);
#endif
		evindex_s_set(&G->evidx, (struct event *)GET_COAL_EVENT(G->localMRCA));
		evindex_s_seek(&G->evidx, t);

		if(G->ev_dxvr){
			if(G->ev_dxvr->t > t){
				struct event *ev_dxvr;

				ev_dxvr = alloc_event(G->cfg, EVENT_DXVR, t);
				remove_event(G, G->ev_dxvr);
				free_event(G->cfg, G->ev_dxvr);

				insert_event(G, ev_dxvr);
				G->ev_dxvr = ev_dxvr;
			}

		}else{
			G->ev_dxvr = alloc_event(G->cfg, EVENT_DXVR, t);
			insert_event(G, G->ev_dxvr);
		}

		return 0;
	}

	// Leave sequential mode and rebuild red-black tree index
	if(rbindex_isseq(G->evidx.idx))
		evindex_seq_off(&G->evidx);
	ev = trace_event(G, t);

#ifdef DEBUG
	fprintf(stderr, "Recombination on %x, t=%.6f, pop=%d, range=[%x(%d, %.6f), %x(%d, %.6f)]\n", e, t, pop, e, e->type, e->t, e->in, e->in->type, e->in->t);
	dump_edges(G);
	fprintf(stderr, "%d:", __LINE__);
	for(i = 0; i < cfg->npop + cfg->nsplt; i++)
		fprintf(stderr, ",G->pops[%d].n=%d, G->pops[%d].enabled=%d", i, G->pops[i].n, i, G->pops[i].enabled);
	fprintf(stderr, "\n");
	fprintf(stderr, "Next event: ev=%x, type=%d, t=%6f\n", ev, ev->type, ev->t);
#endif

	/* Generate recombination node */
	nf = nxover = insert_xover_node(G, e, t);

	/* Iterate until floating lineage is absorbed. */
	coalesced = 0;
	do{
//	n_abs_time_xover++;

		at = abs_time(G, 1, pop, t);
		mg = INFINITY;

		if(npop_all > 1){
			dmig = G->pops[pop].mrate[pop];
			if(dmig > 0)
				mg = dexp(dmig);
		}

		ev = evindex_s_get(&G->evidx);
		if(isinf(at) && isinf(mg) && isinf(ev->t)){
			fprintf(stderr, "%d: Infinite time to next event\n", __LINE__);
			exit(-1);

		}else if(t + at < ev->t || t + mg < ev->t){

//	struct timespec beg, end;
//	int nsec;
//	n_abs_xover++;
//	clock_gettime(CLOCK_MONOTONIC, &beg);

			if(at < mg){		//Next event is absorption
				t += at;
				coalesced = 1;
				e2 = choose_tedge(G, pop, t);

#ifdef DEBUG
				fprintf(stderr, "%d: Absorb floating lineage %x to %x, e=%x\n", __LINE__, nf, e2, e);
#endif

				if(e2 == e){	// Floating lineage is absorbed to the same lineage (loop in ARG)
#ifdef DEBUG
					fprintf(stderr, "%s: %d: A loop occurs!!!\n", __func__, __LINE__);
#endif
//					// e_old->top is the new coalescent node which has to be removed. In this case, e2 must be in local genealogy, so tsindex must be updateda
					if(nf == nxover){
						free_node(G, nxover);

					}else{
						insert_coal_node(e2, nf);
						tsindex_replace(&G->tr_xover, e2->xtid, nf);
						nf->idx = e2->idx;
						G->pops[e2->pop].eptrs[nf->idx] = nf;
						remove_xover_node(G, nxover, e2);
						free_node(G, nxover);
					}

				}else{
					tsindex_update(&G->tr_xover, e2, -(e2->in->t - t));
					last = nd = (struct node *)__absorption(G, e2, nf, pop, t);
					add_edge_r(G, pop, (struct node *)nd);
					add_edge_r(G, pop, nd->out[1]);

					nf = nd;
					evnew = (struct event *)GET_COAL_EVENT(nd);
					insert_event_rb(G, evnew);

					erase_dangling2(G, e);
					remove_xover_node(G, nxover, e);
					free_node(G, nxover);
				}

//	clock_gettime(CLOCK_MONOTONIC, &end);
//	nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//	t_abs_xover += nsec;

			}else{	// Next event is migration
#ifdef DEBUG
				fprintf(stderr, "%d: Next event is migration\n", __LINE__);
#endif
				t += mg;
				nm = __migration(G, nf, pop, t);
				add_edge_r(G, nf->pop, nf);
				nf = (struct node *)nm;
				evnew = (struct event *)GET_MIGR_EVENT(nm);
				insert_event_rb(G, evnew);
				pop = ((struct migr_event *)evnew)->spop;
			}

		}else{
//ndiscard_xover++;
			t = ev->t;

			if(ev->type == EVENT_COAL){
				G->pops[((struct coal_event *)ev)->pop].n--;

			}else if(ev->type == EVENT_MIGR){
				G->pops[((struct migr_event *)ev)->dpop].n--;
				G->pops[((struct migr_event *)ev)->spop].n++;

			}else if(ev->type == EVENT_DUMY || ev->type == EVENT_DXVR){
				struct node_set *F, *trunk;

				trunk = malloc(sizeof(struct node_set) * cfg->npop_all);
				F = malloc(sizeof(struct node_set) * cfg->npop_all);
				for(i = 0; i < cfg->npop_all; i++){
					node_set_init(&trunk[i], 1);
					node_set_init(&F[i], 2);
				}
				// Move edges in dummy edge list to in-tree edge list until t (Note that edges in dummy edge list are ordered by time)
				edum = G->localMRCA;
				ndum = edum->in;
				while(ndum && ndum->t < ev->t){
					edum = ndum;
					ndum = edum->in;
				}

				remove_event_rb(G, ev);

				// Remove remaining edges in dummy edge list
				__remove_edge__(G, edum->pop, edum);
				tsindex_clear(&G->tr_xover, edum);
				if(ev->type == EVENT_DXVR){
					/* Remove dangling edges above dummy recombination event from red-black tree. */
					erase_dummy_path_rb(G, edum);
					free_event(G->cfg, ev);

				}else{
					free_node(G, ndum);
				}
				G->pops[edum->pop].n = 0;
				node_set_add(&F[edum->pop], edum);
				node_set_add(&F[nf->pop], nf);

				G->root = G->localMRCA = NULL;

				G->t = t;
				merge_floating_r(G, trunk, F);

				erase_dangling2(G, e);
				remove_xover_node(G, nxover, e);
				free_node(G, nxover);

				for(i = 0; i < cfg->npop_all; i++){
					node_set_destroy(&trunk[i]);
					node_set_destroy(&F[i]);
				}
				free(F);
				free(trunk);
				coalesced = 1;

			}else{
				update_demography(G, ev);

				if(ev->type == EVENT_JOIN){
					struct join_node *nj;

					jev = (struct join_event *)ev;
					if(jev->popj == pop){
						/* Force the floating lineage moving from population j to population i */
#ifdef DEBUG
						fprintf(stderr, "%s: %d: ", __func__, __LINE__);
#endif
						nj = (struct join_node *)do_join(G, nf, jev->popj, jev->popi, t);
						add_edge_r(G, nf->pop, nf);

						nf = (struct node *)nj;
						nj->ev = (struct join_event *)ev;
						join_set_add(&jev->ndls, (struct node *)nj);

						pop = jev->popi;
						insert_event_rb_join(G, jev);
					}

				}else if(ev->type == EVENT_SPLT){
					struct splt_node *ns;

					sev = (struct splt_event *)ev;
					if(sev->pop == pop){
						u = dunif01();
						if(u >= sev->prop){
							/* Move the floating lineage to new population */
							ns = (struct splt_node *)do_splt(G, nf, sev->pop, sev->newpop, t);
							add_edge_r(G, nf->pop, nf);

							nf = (struct node *)ns;
							ns->ev = (struct splt_event *)ev;
							splt_set_add(&sev->ndls, (struct node *)ns);
							pop = sev->newpop;
							insert_event_rb_splt(G, sev);
						}
					}

				}
			}

			evindex_s_forward(&G->evidx);

		}
	}while(!coalesced);

	if(t > G->localMRCA->t)
		G->localMRCA = last;

	return 0;
}

/* Process coalescent event in trunk genealogy. */
struct node *trunk_coal(struct genealogy *G, struct node_set *trunk, struct coal_event *cev)
{
	struct node *out1, *out2, *enew;
	struct coal_node *in;
	char dead1, dead2;
	int pop;

//	struct timespec beg, end;
//	int nsec;
//	n_trunk_coal++;
//	clock_gettime(CLOCK_MONOTONIC, &beg);

//	in = cev->nd;
	in = GET_COAL_NODE(cev);
	pop = in->pop;
	out1 = in->out[0];
	out2 = in->out[1];

	dead1 = isdeleted(out1);
	dead2 = isdeleted(out2);
	edge_flag_setdeleted((struct node *)in, dead1 & dead2);

#ifdef DEBUG
	fprintf(stderr, "%s: %d: ev=%x(%.6f), in=%x(%.6f), out1=(%x, set_id=%d), out2=(%x, set_id=%d)\n", __func__, __LINE__, cev, cev->t, in, in->t, out1, out1->set_id, out2, out2->set_id);
#endif

	if(dead1 || dead2){
		if(!dead1){
			__remove_event_s(G, (struct event *)cev);
			__node_set_remove(&trunk[pop], out2->set_id);
			__remove_coal_node(in, out1);
			G->tr_xover.weights[out1->xtid] = out1->in->t - out1->t;
			remove_edge_m(G, pop, (struct node *)in);
			remove_edge_m(G, pop, out2);

//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_trunk_coal += nsec;

			return out1;

		}else if(!dead2){
			__remove_event_s(G, (struct event *)cev);

			__node_set_remove(&trunk[pop], out2->set_id);
			node_set_replace(&trunk[pop], out1->set_id, out2);

			__remove_coal_node(in, out2);
			remove_edge_m(G, pop, out1);
			remove_edge_m(G, pop, (struct node *)in);
			G->tr_xover.weights[out2->xtid] = out2->in->t - out2->t;

//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_trunk_coal += nsec;

			return out2;

		}else{
			__remove_event_s(G, (struct event *)cev);

			node_set_replace(&trunk[pop], out1->set_id, (struct node *)in);
			__node_set_remove(&trunk[pop], out2->set_id);
			remove_edge_m(G, pop, out1);
			remove_edge_m(G, pop, out2);

//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_trunk_coal += nsec;

			return (struct node *)in;
		}

	}else{
		node_set_replace(&trunk[pop], out1->set_id, (struct node *)in);
		__node_set_remove(&trunk[pop], out2->set_id);

//		clock_gettime(CLOCK_MONOTONIC, &end);
//		nsec = (end.tv_sec - beg.tv_sec) * MAXNSEC + (end.tv_nsec - beg.tv_nsec);
//		t_trunk_coal += nsec;

		return (struct node *)in;
	}
}

/* Process migration/join/split event in trunk genealogy. */
int trunk_splt(struct genealogy *G, struct node_set *trunk, int dpop, int spop, struct event *ev, struct splt_node *nd)
{
	struct node *e, *in, *out;

	in = (struct node *)nd;
	out = nd->out;
	edge_flag_setdeleted(in, isdeleted(out));
	__node_set_remove(&trunk[dpop], out->set_id);
	node_set_add(&trunk[spop], in);

	if(isdeleted(out)){
		remove_edge_m(G, dpop, out);
		remove_event_splt_decrease(G, (struct splt_event *)ev);
		splt_set_remove(&((struct splt_event *)ev)->ndls, (struct node *)nd);
		return 0;
	}

	return 1;
}

/* Process migration/join/split event in trunk genealogy. */
int trunk_join(struct genealogy *G, struct node_set *trunk, int dpop, int spop, struct join_event *ev, struct join_node *nd)
{
	struct node *e, *in, *out;

	in = (struct node *)nd;
	out = nd->out;
	edge_flag_setdeleted(in, isdeleted(out));
	__node_set_remove(&trunk[dpop], out->set_id);
	node_set_add(&trunk[spop], in);

	if(isdeleted(out)){
		remove_edge_m(G, dpop, out);
		remove_event_join_decrease(G, ev);
		join_set_remove(&ev->ndls, (struct node *)nd);
		return 0;
	}

	return 1;
}

/* Process migration/join/split event in trunk genealogy. */
int trunk_migr(struct genealogy *G, struct node_set *trunk, struct migr_event *ev)
{
	struct node *e, *in, *out;
	int dpop, spop;

	dpop = ev->dpop;
	spop = ev->spop;
	in = (struct node *)GET_MIGR_NODE(ev);
	out = in->out[0];
	edge_flag_setdeleted(in, isdeleted(out));
	__node_set_remove(&trunk[dpop], out->set_id);
	node_set_add(&trunk[spop], in);

	if(isdeleted(out)){
		remove_edge_m(G, dpop, out);
		__remove_event_s(G, (struct event *)ev);
		return 0;
	}

	return 1;
}

double merge_floating(struct genealogy *G, struct node_set *trunk, struct node_set *F)
{
	struct config *cfg;
	int pop, uvpop, zpop, sumnF, i, c, nfrom, rate1, rate2, npop_all;
	double t, uv, minuv, z, minz, rmig;
	double pabs, sum, x, inc, u;
	struct node *last, *nf, *nd, *edum, *ndum, *e;
	struct event *ev, *evnew;
	struct migr_node *nm;
	struct join_event *jev;
	struct splt_event *sev;
	struct list_head *f, *l, *next;

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	npop_all = cfg->npop + cfg->nsplt;
	t = G->t;
	sumnF = 0;
	for(pop = 0; pop < cfg->npop_all; pop++){
		sumnF += F[pop].n;
	}

	/* If trunk genealogy is not empty, loop until all floating lineages are absorbed.
	   Otherwise, loop until only one floating lineage remained. */
	while((G->root != NULL && sumnF > 0) || (G->root == NULL && sumnF > 1)){
		rmig = 0;
		minuv = minz = INFINITY;
		uvpop = zpop = 0;
		for(pop = 0; pop < npop_all; pop++){
			if(F[pop].n > 0){
//n_abs_time_merge++;
				uv = ca_time(G, F[pop].n, pop, t);
#ifdef DEBUG
				fprintf(stderr, "%d: ca_time=%.10f, nF[%d]=%d, G->pops[%d].n=%d\n", __LINE__, uv, pop, F[pop].n, pop, G->pops[pop].n);
#endif
				if(uv < minuv){
					minuv = uv;
					uvpop = pop;
				}
			}
		}

		if(npop_all > 1){
			rmig = 0;
			for(pop = 0; pop < npop_all; pop++)
				rmig += G->pops[pop].mrate[pop] * F[pop].n;

			if(rmig > 0)
				minz = dexp(rmig);
		}

		ev = evindex_s_get(&G->evidx);
		if(isinf(minuv) && isinf(minz) && isinf(ev->t)){
			fprintf(stderr, "%d: Infinite time to next event\n", __LINE__);
			exit(-1);
		}
#ifdef DEBUG
		fprintf(stderr, "%d:", __LINE__);
		for(i = 0; i < npop_all; i++)
			fprintf(stderr, ",G->pops[%d].n=%d", i, G->pops[i].n);
		fprintf(stderr, "\n");

		fprintf(stderr, "%d: Next event: ev=%x, type=%d, t=%6f\n", __LINE__, ev, ev->type, ev->t);
#endif

		if(t + minuv < ev->t || t + minz < ev->t){
			evnew = NULL;
			if(minuv < minz){	// Coalescent or Absorption
				// Calculate probability of absorption event
				rate1 = G->pops[uvpop].n << 1;
				rate2 = F[uvpop].n - 1;

				t += minuv;
				sumnF--;
				if(dunif01() * (rate1 + rate2) < rate1){	//Absorption
					c = dunif(F[uvpop].n);
					nf = node_set_remove(&F[uvpop], c);
					last = (struct node *)absorption(G, trunk, nf, uvpop, t);
					if(last)
						evnew = (struct event *)GET_COAL_EVENT(last);

				}else{	// Coalescent
					last = nd = (struct node *)coalescent(G, F, uvpop, t);
					add_edge_m(G, uvpop, nd->out[0]);
					add_edge_m(G, uvpop, nd->out[1]);
					evnew = (struct event *)GET_COAL_EVENT(nd);
				}

			}else{	// Migration
				t += minz;
				x = rmig * dunif01();
				sum = 0;
				for(zpop = 0; zpop < npop_all; zpop++){
					inc = G->pops[zpop].mrate[zpop] * F[zpop].n;
					if(x < sum + inc)
						break;
					else
						sum += inc;
				}
				c = (int)((x - sum) / G->pops[zpop].mrate[zpop]);

				// Find the lineage to be migrated
				nd = node_set_remove(&F[zpop], c);

				/* Perform migration */
#ifdef DEBUG
				fprintf(stderr, "%s: %d: ", __func__, __LINE__);
#endif
				nm = __migration(G, nd, zpop, t);
				add_edge_m(G, nd->pop, nd);

				last = (struct node *)nm;
				evnew = (struct event *)GET_MIGR_EVENT(nm);
				node_set_add(&F[((struct migr_event *)evnew)->spop], (struct node *)nm);
			}

			if(evnew)	// evnew is NULL when the absorption event is ignored because the absorption target will be removed later
				insert_event_s(G, evnew);

		}else{
//ndiscard_merge++;
			t = ev->t;
			evindex_s_forward(&G->evidx);

			if(ev->type == EVENT_COAL){
				G->pops[((struct coal_event *)ev)->pop].n--;

				if(GET_COAL_NODE(ev) != (struct coal_node *)G->localMRCA){
					trunk_coal(G, trunk, (struct coal_event *)ev);

				}else{
					pop = G->localMRCA->pop;
					e = trunk_coal(G, trunk, (struct coal_event *)ev);
					if(isdeleted(e)){
#ifdef DEBUG
						fprintf(stderr, "Both branch of old MRCA is removed!!!\n");
#endif
						G->pops[pop].n--;
						G->troot = G->root->t;
						__node_set_remove(&trunk[pop], e->set_id);
						erase_dummy_path_s(G, e);
						if(G->ev_dxvr){
							__remove_event_s(G, G->ev_dxvr);
							free_event(G->cfg, G->ev_dxvr);
						}
						G->localMRCA = G->root = NULL;

					}else{
#ifdef DEBUG
						fprintf(stderr, "A branch of old MRCA is removed!!!\n");
#endif
						G->localMRCA = e;	// Move down MRCA
					}
				}

			}else if(ev->type == EVENT_MIGR){
				G->pops[((struct migr_event *)ev)->dpop].n--;
				G->pops[((struct migr_event *)ev)->spop].n++;
				trunk_migr(G, trunk, (struct migr_event *)ev);

			}else{
				int i;
				update_demography(G, ev);

				if(ev->type == EVENT_JOIN){
					struct join_node *nj;

					jev = (struct join_event *)ev;
					/* Move edges of trunk genealogy. */
					i = 0;
					while(i < jev->ndls.n){
						nj = (struct join_node *)node_set_get(&jev->ndls, i);
						if(trunk_join(G, trunk, jev->popj, jev->popi, (struct join_event *)ev, nj))
							i++;
					}

					/* Move all new lineages in population j to population i. */
					for(i = 0; i < F[jev->popj].n; i++){
						nd = node_set_get(&F[jev->popj], i);
#ifdef DEBUG
						fprintf(stderr, "%s: %d: ", __func__, __LINE__);
#endif
						nj = (struct join_node *)do_join(G, nd, jev->popj, jev->popi, t);
						add_edge_m(G, nd->pop, nd);

						node_set_add(&F[jev->popi], (struct node *)nj);
						nj->ev = (struct join_event *)ev;
						join_set_add(&jev->ndls, (struct node *)nj);
						insert_event_s_join(G, (struct event *)ev);
					}

					node_set_clear(&F[jev->popj]);

				}else if(ev->type == EVENT_SPLT){
					struct splt_node *ns;

					sev = (struct splt_event *)ev;
					/* Move edges of trunk genealogy. */
					i = 0;
					while(i < sev->ndls.n){
						ns = (struct splt_node *)node_set_get(&sev->ndls, i);
						if(trunk_splt(G, trunk, sev->pop, sev->newpop, ev, ns))
							i++;
					}

					/* Move new lineages in population old population to new population with probability sev->prop. */
					i = 0;
					while(i < F[sev->pop].n){
						u = dunif01();
						if(u >= sev->prop){
							nd = node_set_remove(&F[sev->pop], i);
							ns = (struct splt_node *)do_splt(G, nd, sev->pop, sev->newpop, t);
							add_edge_m(G, nd->pop, nd);

							node_set_add(&F[sev->newpop], (struct node *)ns);
							ns->ev = (struct splt_event *)ev;
							splt_set_add(&sev->ndls, (struct node *)ns);
							insert_event_s_splt(G, (struct event *)ev);

						}else{
							i++;
						}
					}

				}else if(ev->type == EVENT_DUMY || ev->type == EVENT_DXVR){
#ifdef DEBUG
					if(ev->type == EVENT_DUMY){
						fprintf(stderr, "%s: %d: DUMY event is found at time %.6f\n", __func__, __LINE__, ev->t);

					}else{
						fprintf(stderr, "%s: %d: DXVR event is found at time %.6f\n", __func__, __LINE__, ev->t);
					}
#endif
					sumnF++;

					// Move edges in dummy edge list to in-tree edge list until t (Note that edges in dummy edge list are ordered by time)
					edum = G->localMRCA;
					ndum = edum->in;
					while(ndum && ndum->t < ev->t){
						edum = ndum;
						ndum = edum->in;
					}

					for(i = 0; i < npop_all; i++)
						node_set_clear(&trunk[i]);

					__remove_event_s(G, ev);
					// Remove remaining edges in dummy edge list
					__remove_edge__(G, edum->pop, edum);
					tsindex_clear(&G->tr_xover, edum);
					if(ev->type == EVENT_DXVR){
						/* Remove dangling edges above dummy recombination event from red-black tree. */
						erase_dummy_path(G, edum);
						free_event(G->cfg, ev);

					}else{
						free_node(G, ndum);
					}

					G->pops[edum->pop].n = 0;
					node_set_add(&F[edum->pop], edum);

					G->root = G->localMRCA = NULL;
				}
			}
		}

	}

	if(G->localMRCA == NULL){	// In this case, last event must be coalescent between two floating lineages
		for(i = 0; i < npop_all; i++){
			if(F[i].n > 0){
				nd = node_set_remove(&F[i], 0);
				ndum = alloc_node(G, NODE_DUMMY, nd->pop, nd->t);
				init_event(G->cfg, (struct event *)GET_DUMMY_EVENT(ndum), EVENT_DUMY, ndum->t);
				ndum->in = NULL;
				AS_DUMMY_NODE(ndum)->out = nd;
				nd->in = ndum;
				e = nd;
				break;
			}
			if(trunk[i].n > 0){
				e = node_set_remove(&trunk[i], 0);
				break;
			}
		}
		edge_flag_settype(e->in, NODE_DUMMY);
		e->in->t = e->t;
		e->in->pop = e->pop;
		e->in->in = NULL;
		add_edge_m(G, e->pop, e);
		G->troot = e->in->t;

		G->root = e->in;
		G->localMRCA = e;

		evnew = (struct event *)GET_DUMMY_EVENT(e->in);
		// Change on 2018/05/23: This is necessary because the next event may be demographic events before G->troot (old TMRCA).
		while((evindex_s_get(&G->evidx))->t < evnew->t)
			evindex_s_forward(&G->evidx);
		insert_event(G, evnew);

	}else if(t > G->localMRCA->t){
		G->localMRCA = last;
	}

#ifdef DEBUG
	fprintf(stderr, "%d: Leaving %s", __LINE__, __func__);
#endif
	return 0;
}

void destroy_tree(struct genealogy *G, struct node *nd)
{
	if(iscoalnode(nd)){
		struct coal_node *n;

		n = (struct coal_node *)nd;
		remove_event(G, (struct event *)GET_COAL_EVENT(n));
		destroy_tree(G, n->out[0]);
		destroy_tree(G, n->out[1]);

	}else if(ismigrnode(nd)){
		remove_event(G, (struct event *)GET_MIGR_EVENT(nd));
		destroy_tree(G, nd->out[0]);

	}else if(isjoinnode(nd)){
		remove_event_join_decrease(G, ((struct join_node *)nd)->ev);
		destroy_tree(G, nd->out[0]);

	}else if(isspltnode(nd)){
		remove_event_splt_decrease(G, ((struct splt_node *)nd)->ev);
		destroy_tree(G, nd->out[0]);

	}else if(isfloatnode(nd)){
		remove_event(G, (struct event *)GET_FLOAT_EVENT(nd));
		destroy_tree(G, nd->out[0]);

	}else if(isdummynode(nd)){
		remove_event(G, (struct event *)GET_DUMMY_EVENT(nd));
		destroy_tree(G, nd->out[0]);
	}

	free_node(G, nd);
}

void destroy_pop(struct genealogy *G, struct population *p)
{
	struct list_head *l;
	int i;

	free(p->mrate);
	free(p->eptrs);

	while(p->idx_queue.front){
		l = __list_pop(&p->idx_queue);
		free(l);
	}

	while(p->id_list.front){
		l = __list_pop(&p->id_list);
		free(l);
	}
}

void clear_genealogy(struct genealogy *G)
{
	struct config *cfg;
	struct list_head *l;
	struct list *eq;
	struct event *ev0, *ev;
	int pop, i;

	cfg = G->cfg;
	if(G->root){
//		destroy_tree(G, G->root);
		G->root = G->localMRCA = NULL;
	}
	cache_clear(G->node_cache[NODE_COAL]);
	cache_clear(G->node_cache[NODE_MIGR]);
	cache_clear(G->node_cache[NODE_SAM]);
	cache_clear(G->node_cache[NODE_FLOAT]);
	cache_clear(G->node_cache[NODE_JOIN]);
	cache_clear(G->node_cache[NODE_SPLT]);

	G->total = 0;

	// Detach right sentinel from event index
	l = __list_pop(&G->evidx.idx->ls);
	G->evidx.idx->n--;
	ev0 = (struct event *)GET_OBJ(l);
	dn_clear(cfg->npop_all, GET_DN(ev0));

	// Detach left sentinel from event index
	l = G->evidx.idx->ls.front;
	__list_remove(&G->evidx.idx->ls, l);
	G->evidx.idx->n--;
	ev0 = (struct event *)GET_OBJ(l);
	dn_clear(cfg->npop_all, GET_DN(ev0));

	if(G->ev_dxvr){
		remove_event(G, G->ev_dxvr);
		free_event(cfg, G->ev_dxvr);
		G->ev_dxvr = NULL;
	}

	for(i = 0; i < cfg->ndevents; i++){
		if(cfg->devents[i]->type == EVENT_SPLT)
			node_set_clear(&((struct splt_event *)cfg->devents[i])->ndls);
		else if(cfg->devents[i]->type == EVENT_JOIN)
			node_set_clear(&((struct join_event *)cfg->devents[i])->ndls);
	}

	// Clear event list
	while(G->evidx.idx->ls.front){
		l = __list_pop(&G->evidx.idx->ls);
		ev = (struct event *)GET_OBJ(l);
		if(ev->type == EVENT_DXVR)
			free_event(G->cfg, ev);
	}

	tsindex_reset(&G->tr_xover);

	for(pop = 0; pop < cfg->npop + cfg->nsplt; pop++){
		eq = &G->pops[pop].idx_queue;
		while(eq->front){
			l = __list_pop(eq);
			__list_append(&G->pops[pop].id_list, l);
		}
		memset(G->pops[pop].eptrs, 0, sizeof(struct node *) * G->pops[pop].maxedges);
		G->pops[pop].nedges = 0;
		G->pops[pop].nsam = G->pops[pop].n = 0;
	}

	evindex_reset(G, &G->evidx);
}

struct cache_data {
	int npop;
	int n_type;
	int e_type;
};

void init_dn_off(struct node *nd, struct cache_data *data)
{
	struct event *ev;

	nd->type = data->n_type;
	ev = (struct event *)((char *)nd + nodesize[data->n_type]);
	ev->type = data->e_type;
	ev->dn_off = evsize[data->e_type];
	ev->sumdn_off = evsize[data->e_type] + sizeof(int) * data->npop;
}

struct genealogy *alloc_genealogy(struct config *cfg, struct profile *prof)
{
	int pop, npop, nsplt, i, npop_all;
	struct genealogy *G;
	struct list_head *l;
	struct cache_data *cd;

	npop = cfg->npop;
	nsplt = cfg->nsplt;
	npop_all = npop + nsplt;

	G = malloc(sizeof(struct genealogy));
	memset(G, 0, sizeof(struct genealogy));

	G->cfg = cfg;

	cd = malloc(sizeof(struct cache_data));
	cd->npop = cfg->npop_all;
	cd->n_type = NODE_COAL;
	cd->e_type = EVENT_COAL;
	G->node_cache[NODE_COAL] = cache_create(sizeof(struct coal_node) + sizeof(struct coal_event) + sizeof(int) * 2 * npop_all, cfg->maxfrag * 4, init_dn_off, cd);

	cd = malloc(sizeof(struct cache_data));
	cd->npop = cfg->npop_all;
	cd->n_type = NODE_MIGR;
	cd->e_type = EVENT_MIGR;
	G->node_cache[NODE_MIGR] = cache_create(sizeof(struct migr_node) + sizeof(struct migr_event) + sizeof(int) * 2 * npop_all, cfg->maxfrag * 2, init_dn_off, cd);

	G->node_cache[NODE_SAM] = cache_create(sizeof(struct sam_node), cfg->prof->nfrag, NULL, NULL);

	cd = malloc(sizeof(struct cache_data));
	cd->npop = cfg->npop_all;
	cd->n_type = NODE_DUMMY;
	cd->e_type = EVENT_DUMY;
	G->node_cache[NODE_FLOAT] = cache_create(sizeof(struct dummy_node) + sizeof(struct event) + sizeof(int) * 2 * npop_all, cfg->maxfrag * 2, init_dn_off, cd);

	G->node_cache[NODE_DUMMY] = G->node_cache[NODE_FLOAT];
	G->node_cache[NODE_JOIN] = cache_create(sizeof(struct join_node) + sizeof(int) * 2 * npop_all, cfg->maxfrag * 2, NULL, NULL);
	G->node_cache[NODE_SPLT] = cache_create(sizeof(struct splt_node) + sizeof(int) * 2 * npop_all, cfg->maxfrag * 2, NULL, NULL);

	G->pops = malloc(sizeof(struct population) * (npop + nsplt));
	memset(G->pops, 0, sizeof(struct population) * (npop + nsplt));
	for(pop = 0; pop < npop + nsplt; pop++){
		G->pops[pop].mrate = malloc(sizeof(double) * (npop + nsplt));
		memset(G->pops[pop].mrate, 0, sizeof(double) * (npop + nsplt));

		if(pop > npop){
			G->pops[pop].enabled = 0;

		}else{
			G->pops[pop].enabled = 1;
		}

		list_init(&G->pops[pop].idx_queue);
		list_init(&G->pops[pop].id_list);
		G->pops[pop].maxedges = prof->nfrag * 5;
		G->pops[pop].eptrs = malloc(sizeof(struct node *) * G->pops[pop].maxedges);
		G->pops[pop].nedges = 0;
	}
	G->maxR = 4 * cfg->maxfrag;
	G->R[0] = malloc(sizeof(int) * G->maxR);
	G->R[1] = malloc(sizeof(int) * G->maxR);

	evindex_init(G, G->cfg, &G->evidx);
	evindex_seq_on(&G->evidx);
	evindex_s_rewind(&G->evidx);
	for(i = 0; i < cfg->ndevents; i++)
		evindex_s_insert(&G->evidx, cfg->devents[i]);

	/* Set up mutation model of populations that exist at time 0. */
	for(pop = 0; pop < npop; pop++){
		G->pops[pop].mmut = cfg->mmut[pop];
	}

	/* Set up mutation model of populations generated by SPLT event. */
	evindex_s_rewind(&G->evidx);
	while(!evindex_s_end(&G->evidx)){
		struct event *ev;
		ev = evindex_s_get(&G->evidx);
		if(ev->type == EVENT_SPLT){
			struct splt_event *sev;

			sev = (struct splt_event *)ev;
			if(cfg->mmut[sev->newpop] == NULL){	// If user does not specify mutation model of a population that created by SPLT event, then it inherits mutation model of original population
				G->pops[sev->newpop].mmut = cfg->mmut[sev->pop];

			}else{
				G->pops[sev->newpop].mmut = cfg->mmut[sev->newpop];
			}
		}
		evindex_s_forward(&G->evidx);
	}

	tsindex_init(&G->tr_xover, cfg->maxfrag * 5);
	G->trunk = malloc(sizeof(struct node_set) * npop_all);
	for(i = 0; i < npop + nsplt; i++)
		node_set_init(&G->trunk[i], cfg->maxfrag * 4);

	return G;
}

void destroy_genealogy(struct genealogy *G)
{
	struct list_head *l;
	struct config *cfg;
	struct event *ev;
	int pop, i;

	tsindex_destroy(&G->tr_xover);

	cfg = G->cfg;
#ifdef DEBUG
	fprintf(stderr, "Entering function %s\n", __func__);
#endif
	if(G->root){
#ifdef DEBUG
		fprintf(stderr, "root=%x\n", G->root);
#endif
		destroy_tree(G, G->root);
	}
	
	for(i = 0; i < cfg->npop + cfg->nsplt; i++)
		node_set_destroy(&G->trunk[i]);
	free(G->trunk);

	for(pop = 0; pop < cfg->npop + cfg->nsplt; pop++)
		destroy_pop(G, &G->pops[pop]);
	free(G->pops);

	// Detach right sentinel from event index
	l = __list_pop(&G->evidx.idx->ls);

	// Detach left sentinel from event index
	l = G->evidx.idx->ls.front;
	__list_remove(&G->evidx.idx->ls, l);

	while(G->evidx.idx->ls.front){
		l = __list_pop(&G->evidx.idx->ls);
		ev = (struct event *)GET_OBJ(l);
		if(ev->type == EVENT_DUMY || ev->type == EVENT_DXVR)
			free(l);
	}

	__evindex_destroy(G, &G->evidx);

	free(G->node_cache[NODE_COAL]->data);
	cache_destroy(G->node_cache[NODE_COAL]);

	free(G->node_cache[NODE_MIGR]->data);
	cache_destroy(G->node_cache[NODE_MIGR]);

	cache_destroy(G->node_cache[NODE_SAM]);

	free(G->node_cache[NODE_FLOAT]->data);
	cache_destroy(G->node_cache[NODE_FLOAT]);

	cache_destroy(G->node_cache[NODE_JOIN]);
	cache_destroy(G->node_cache[NODE_SPLT]);

	free(G->R[0]);
	free(G->R[1]);

	free(G);
#ifdef DEBUG
	fprintf(stderr, "Finishing function %s\n\n", __func__);
#endif
}

void print_tree(FILE *out_fp, struct node *nd, struct config *cfg)
{
	if(issamnode(nd)){
#ifdef DEBUG
		fprintf(stderr, "sam_node=%x", nd);
#else
		fprintf(out_fp, "%d", cfg->prof->fgid[AS_SAM_NODE(nd)->fgid]);
#endif

	}else if(iscoalnode(nd)){
		struct node *n1, *n2;

		fprintf(out_fp, "(");

		n2 = AS_COAL_NODE(nd)->out[0];
		while(!iscoalnode(n2) && !issamnode(n2))
			n2 = AS_MIGR_NODE(n2)->out;
		print_tree(out_fp, n2, cfg);
		fprintf(out_fp, ":%.10f", nd->t - n2->t);

		fprintf(out_fp, ",");

		n2 = AS_COAL_NODE(nd)->out[1];
		while(!iscoalnode(n2) && !issamnode(n2))
			n2 = AS_MIGR_NODE(n2)->out;
		print_tree(out_fp, n2, cfg);
		fprintf(out_fp, ":%.10f", nd->t - n2->t);

#ifdef DEBUG
		fprintf(out_fp, ")%x:%.6f", nd, nd->t);
#else
		fprintf(out_fp, ")");
#endif
	}else if(isdummynode(nd)){
		struct node *n2;

#ifdef DEBUG
		fprintf(out_fp, "(");
#endif
		n2 = AS_DUMMY_NODE(nd)->out;
		while(!iscoalnode(n2) && !issamnode(n2))
			n2 = AS_MIGR_NODE(n2)->out;
		print_tree(out_fp, n2, cfg);

#ifdef DEBUG
		fprintf(out_fp, ":%.10f", nd->t - n2->t);
		fprintf(out_fp, ")%x:%.6f", nd, nd->t);
#else
		fprintf(out_fp, ")");
#endif
	}
}

int cnt_rec;
/* Main algorithm of the coalescent simulator. */
int simulate(struct genealogy *G, struct profile *prof)
{
	struct config *cfg;
	struct reference *ref;
	struct list_head *l, *tmp, *fgl;
	struct read **rdset, *rd;
	int f, pop, npop_all, ilast, i, j;
	int nfrag, reflen, nR, nRold, *R, *Rold, maxR, *fgid;
	int *fgstart, *fgend;
	struct fginfo *fgi;
	struct node_set *F;
	struct sam_node **nds;
	struct timespec begin, end;
	double rho;
	double lb, ub;

	clock_gettime(CLOCK_MONOTONIC, &begin);

	nfrag = prof->nfrag;
	rdset = prof->rdset;

	ref = prof->ref;
	reflen = prof->ref->chrlen[prof->chrnum];
	reload_reference(ref, prof->chrnum);
	fgstart = prof->fgstart;
	fgi = prof->info;
	fgid = prof->fgid;
	nds = prof->nds;

	cfg = G->cfg;
	for(i = 0; i < nfrag; i++){
		nds[i] = (struct sam_node *)alloc_node(G, NODE_SAM, fgi[i].pop, 0);
		nds[i]->fgid = i;
	}

#ifdef DEBUG
	fprintf(stderr, "Entering %s\n", __func__);

	/* Print initial configuration. */
	fprintf(stderr, "Initial migration matrix:[\n");
	for(pop = 0; pop < cfg->npop; pop++){
		int i;
		for(i = 0; i < cfg->npop; i++)
			fprintf(stderr, "%.6f,", cfg->mmig[pop][i]);
		fprintf(stderr, "\n");
	}
	fprintf(stderr, "]\n");

	/* Print growth rate. */
	fprintf(stderr, "Initial growth:[");
	for(pop = 0; pop < cfg->npop; pop++)
		fprintf(stderr, "%.6f,", cfg->grate[pop]);
	fprintf(stderr, "]\n");

	/* Print subpopulation size. */
	fprintf(stderr, "Initial subpopulation size:[");
	for(pop = 0; pop < cfg->npop; pop++)
		fprintf(stderr, "%.6f,", cfg->size[pop]);
	fprintf(stderr, "]\n");

	dump_events(G);
#endif
	npop_all = cfg->npop_all;

	seed();
	F = malloc(sizeof(struct node_set) * npop_all);

	/* Load next fragment sets. */
	for(i = 0; i < npop_all; i++){
		node_set_clear(&G->trunk[i]);
		node_set_init(&F[i], (cfg->maxfrag + 1));
	}

	rho = cfg->rho;
	lb = ub = 0;
	ilast = 0;
	f = 0;
	G->ev_dxvr = NULL;

	G->nR[0] = G->nR[1] = 0;
	G->curridx = 0;
	R = G->R[0];
	Rold = G->R[1];
	do{
		struct list_head *fgl, *nl, *next, *rl;
		struct sam_node *nd;
		int i, j, n0, ntrunk, ub_i, lb_i;
		struct event *ev0;
		double x;

#ifdef DEBUG
		fprintf(stderr, "%s: %d: Tree before merge_floating:", __func__, __LINE__);
		if(G->root)
			print_tree(stderr, G->root, G->cfg);
		fprintf(stderr, "\n");
#endif

		nR = G->nR[G->curridx];
		if(nR + cfg->maxfrag >= G->maxR){
			G->maxR += cfg->maxfrag;
			G->R[0] = realloc(G->R[0], sizeof(int) * G->maxR);
			G->R[1] = realloc(G->R[1], sizeof(int) * G->maxR);
		}

		Rold = G->R[1 - G->curridx];
		R = G->R[G->curridx];

		ev0 = (struct event *)GET_OBJ(G->evidx.idx->ls.front);
		for(i = 0; i < cfg->maxfrag && f < nfrag; i++, f++){
			R[nR++] = f;
			node_set_add(&F[fgi[f].pop], (struct node *)nds[f]);
		}
		G->nR[G->curridx] = nR;

		for(i = 0; i < npop_all; i++)
			node_set_resize(&G->trunk[i], (nR + 1));

		for(i = 0; i < cfg->npop_all; i++)
			GET_DN(ev0)[i] += F[i].n;

		if(f < nfrag){
			ub = (double)fgstart[f] / reflen;

		}else{
			ub = 1;
		}

#ifdef DEBUG
		fprintf(stderr, "%d: New reads: R", __LINE__);
		for(i = 0; i < nR; i++){
			fprintf(stderr, "->(id=%d, start=%d, end=%d)", fgid[R[i]], prof->fgstart[R[i]], prof->info[R[i]].end);
		}
		fprintf(stderr, "\n");
		fprintf(stderr, "%d: lb=%.6f, ub=%.6f\n", __LINE__, lb, ub);
#endif

		/* Remove reads in temporary list to main list. */
#ifdef DEBUG
		fprintf(stderr, "%d: Rold", __LINE__);
		for(i = 0; i < nR; i++){
			fprintf(stderr, "->(%d, start=%d, end=%d)", fgid[R[i]], prof->fgstart[R[i]], prof->info[R[i]].end);
		}
		fprintf(stderr, "\n");
#endif

		reset_populations(G);
		for(pop = 0; pop < cfg->npop; pop++){
			G->pops[pop].nsam += F[pop].n;
		}
		G->t = 0;

#ifdef DEBUG
		fprintf(stderr, "%s: %d: lb=%.6f, ub=%.6f\n", __func__, __LINE__, lb, ub);
#endif

		tsindex_setflag(&G->tr_xover, TSINDEX_REBUILD);
		evindex_seq_on(&G->evidx);

		merge_floating(G, G->trunk, F);

#ifdef DEBUG
		fprintf(stderr, "%s: %d: G->root=%x(%.6f), G->localMRCA=%x(%.6f)\n\n", __func__, __LINE__, G->root, G->root->t, G->localMRCA, G->localMRCA->t);
#endif
		clear_tree(G);

		for(i = 0; i < cfg->npop_all; i++)
			G->pops[i].nsam = GET_DN(ev0)[i];

#ifdef DEBUG
		fprintf(stderr, "%s: %d: Tree after clear_tree:", __func__, __LINE__);
		if(G->root)
			print_tree(stderr, G->root, G->cfg);
		fprintf(stderr, "\n");
		dump_edges(G);
#endif

#ifdef DEBUG
		fprintf(stderr, "%s: %d: G->root=%x(%.6f), G->localMRCA=%x(%.6f)\n\n", __func__, __LINE__, G->root, G->root->t, G->localMRCA, G->localMRCA->t);
#endif

#ifdef DEBUG
		fprintf(stderr, "%d: G->root=%x, G->root->t=%.6f, G->localMRCA=%x, G->localMRCA->t=%.6f\n", __LINE__, G->root, G->root->t, G->localMRCA, G->localMRCA->t);

		/* Print event list. */
		dump_events(G);

		fprintf(stderr, "%d:", __LINE__);
		dump_edges(G);
		print_tree(stderr, G->localMRCA, G->cfg);
#endif

		x = lb;
		do{
			double u, rrho, r, treesize;
			int inext, to;

			G->total = L(G);
			treesize = G->total;
			rrho = rho * treesize;
			if(rrho > 0){
				r = dexp(rrho);

			}else{
				r = (ub - x);	/* No recombination. */
			}

#ifdef DEBUG
			fprintf(stderr, "%d: G->total=%.6f, lb=%.6f, ub=%.6f, x=%.6f, r=%.6f\n", __LINE__, G->total, lb, ub, x, r);
#endif
			x = MIN(x + r, ub);
			inext = x * reflen - ilast;

#ifdef DEBUG
			fprintf(stderr, "\nL=%.10f, getRate()=%.10f, curPos=%.10f, off=%.10f, inext=%d, ilast=%d\n", G->total, rrho, x, r, inext, ilast);
			fprintf(stderr, "%d: ", __LINE__);
			print_tree(stderr, G->root, G->cfg);
			fprintf(stderr, "\n");
#endif
			if(inext > 0){	// If next recombination doesn't occur on current nucleotide position, output local tree or sequence
				to = x * reflen;
				if(cfg->print_tree){
//fprintf(stderr, "%s: %d: x=%.6f\n", __func__, __LINE__, x);
					fprintf(cfg->treefp, "[%d]", to - ilast);
					print_tree(cfg->treefp, G->localMRCA, G->cfg);
					fprintf(cfg->treefp, ";\n");
				}

				if(cfg->gensam)
					generate_sequence(ref, G, ilast, to);
				ilast = to;
			}
#ifdef DEBUG
			fprintf(stderr, "%d:", __LINE__);
			print_tree(stderr, G->root, G->cfg);
			fprintf(stderr, "\n");
#endif
			if(x < ub){
#ifdef DEBUG
				fprintf(stderr, "%s: %d: x=%.6f\n", __func__, __LINE__, x);
#endif
				recombination(G, x);
			}

#ifdef DEBUG
			dump_events(G);

			fprintf(stderr, "%d: edge list:", __LINE__);
			dump_edges(G);
			fprintf(stderr, "\n");
			print_tree(stderr, G->localMRCA, G->cfg);
			fprintf(stderr, "\n");
#endif
		}while(x < ub);
		lb = ub;

#ifdef DEBUG
		fprintf(stderr, "%d:", __LINE__);
		print_tree(stderr, G->root, G->cfg);
		fprintf(stderr, "\n");
#endif

		for(i = 0; i < npop_all; i++){
			node_set_clear(&G->trunk[i]);
			node_set_clear(&F[i]);
		}

		/* Output finished fragments. */
		nRold = 0;
		lb_i = lb * reflen;
		for(i = 0; i < nR; i++){
#ifdef DEBUG
			fprintf(stderr, "Fragment %d, nread=%d\n", fgid[R[i]], fgi[R[i]].nread);
#endif
			nd = nds[R[i]];
			node_set_add(&G->trunk[nd->pop], (struct node *)nd);
			if(fgi[R[i]].end <= lb_i && fgi[R[i]].trunk == 0){
#ifdef DEBUG
				fprintf(stderr, "Finishing fragment %d\n", fgid[R[i]]);
#endif
				GET_DN(ev0)[nd->pop]--;
				edge_flag_delete((struct node *)nd);

			}else{
				Rold[nRold++] = R[i];
			}
		}
		G->nR[1 - G->curridx] = nRold;
		G->curridx = 1 - G->curridx;
	}while(lb < 1);
	
	for(i = 0; i < npop_all; i++)
		node_set_destroy(&F[i]);
	
	free(F);

	clock_gettime(CLOCK_MONOTONIC, &end);

#ifdef DEBUG
	fprintf(stderr, "Finishing %s\n\n", __func__);
#endif

//	fprintf(stderr, "cnt_rec=%d\n", cnt_rec);

//	fprintf(cfg->treefp, "%d\t%d\t%d\t%d\n", begin.tv_sec, begin.tv_nsec, end.tv_sec, end.tv_nsec);

/*fprintf(stderr, "t_abs_merge=%lu\n", t_abs_merge);
fprintf(stderr, "n_abs_merge=%lu\n", n_abs_merge);

fprintf(stderr, "t_abs_xover=%lu\n", t_abs_xover);
fprintf(stderr, "n_abs_xover=%lu\n", n_abs_xover);

fprintf(stderr, "t_coal=%lu\n", t_coal);
fprintf(stderr, "n_coal=%lu\n", n_coal);

fprintf(stderr, "t_abs_time=%lu\n", t_abs_time);
fprintf(stderr, "n_abs_time_xover=%lu\n", n_abs_time_xover);
fprintf(stderr, "n_abs_time_merge=%lu\n", n_abs_time_merge);

fprintf(stderr, "t_coal_time=%lu\n", t_coal_time);
fprintf(stderr, "n_coal_time=%lu\n", n_coal_time);

fprintf(stderr, "ndiscard_merge=%lu\n", ndiscard_merge);
fprintf(stderr, "ndiscard_xover=%lu\n", ndiscard_xover);

fprintf(stderr, "n_build_trunk=%lu\n", n_build_trunk);
fprintf(stderr, "t_build_trunk=%lu\n", t_build_trunk);

fprintf(stderr, "n_clear_tree=%lu\n", n_clear_tree);
fprintf(stderr, "t_clear_tree=%lu\n", t_clear_tree);

fprintf(stderr, "t_ts_rebuild=%lu\n", t_ts_rebuild);
fprintf(stderr, "n_ts_resize=%lu\n", n_ts_resize);

fprintf(stderr, "t_ev_tree=%lu\n", t_ev_tree);
fprintf(stderr, "t_ev_summary=%lu\n", t_ev_summary);

fprintf(stderr, "t_trunk_coal=%lu\n", t_trunk_coal);
fprintf(stderr, "n_trunk_coal=%lu\n", n_trunk_coal);*/

	return 0;
}

